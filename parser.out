Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> run
Rule 1     run -> program
Rule 2     program -> program function
Rule 3     program -> program function_call
Rule 4     program -> program variable
Rule 5     program -> program token
Rule 6     program -> function
Rule 7     program -> function_call
Rule 8     program -> variable
Rule 9     program -> token
Rule 10    function -> FN id ( parameter ) { body }
Rule 11    function -> COMMAND id ( parameter ) { body }
Rule 12    token -> TOKEN ( string )
Rule 13    function_call -> id ( term_list )
Rule 14    parameter -> id , parameter
Rule 15    parameter -> id
Rule 16    parameter -> empty
Rule 17    body -> body exp
Rule 18    body -> body variable
Rule 19    body -> exp
Rule 20    body -> variable
Rule 21    exp -> term binop exp
Rule 22    exp -> term
Rule 23    exp -> IF exp { body } ELSE { body }
Rule 24    exp -> IF exp { body }
Rule 25    exp -> TRY { body } CATCH { body }
Rule 26    variable -> id = exp
Rule 27    term_map -> term : term , term_map
Rule 28    term_map -> term : term
Rule 29    term_list -> term_list , term
Rule 30    term_list -> term
Rule 31    term -> unop term
Rule 32    term -> number
Rule 33    term -> boolean
Rule 34    term -> string
Rule 35    term -> function_call
Rule 36    term -> id
Rule 37    term -> list
Rule 38    term -> dict
Rule 39    term -> empty
Rule 40    unop -> SIGN
Rule 41    unop -> UNITARY_OPERATOR
Rule 42    binop -> SIGN
Rule 43    binop -> BINARY_OPERATOR
Rule 44    dict -> { term_map }
Rule 45    dict -> { empty }
Rule 46    list -> [ term_list ]
Rule 47    number -> FLOAT
Rule 48    number -> INTEGER
Rule 49    boolean -> BOOLEAN
Rule 50    string -> STRING
Rule 51    id -> ID
Rule 52    empty -> <empty>

Terminals, with rules where they appear

(                    : 10 11 12 13
)                    : 10 11 12 13
,                    : 14 27 29
:                    : 27 28
=                    : 26
BINARY_OPERATOR      : 43
BOOLEAN              : 49
CATCH                : 25
COMMAND              : 11
ELSE                 : 23
FLOAT                : 47
FN                   : 10
ID                   : 51
IF                   : 23 24
INTEGER              : 48
SIGN                 : 40 42
STRING               : 50
TOKEN                : 12
TRY                  : 25
UNITARY_OPERATOR     : 41
[                    : 46
]                    : 46
error                : 
{                    : 10 11 23 23 24 25 25 44 45
}                    : 10 11 23 23 24 25 25 44 45

Nonterminals, with rules where they appear

binop                : 21
body                 : 10 11 17 18 23 23 24 25 25
boolean              : 33
dict                 : 38
empty                : 16 39 45
exp                  : 17 19 21 23 24 26
function             : 2 6
function_call        : 3 7 35
id                   : 10 11 13 14 15 26 36
list                 : 37
number               : 32
parameter            : 10 11 14
program              : 1 2 3 4 5
run                  : 0
string               : 12 34
term                 : 21 22 27 27 28 28 29 30 31
term_list            : 13 29 46
term_map             : 27 44
token                : 5 9
unop                 : 31
variable             : 4 8 18 20

Parsing method: LALR

state 0

    (0) S' -> . run
    (1) run -> . program
    (2) program -> . program function
    (3) program -> . program function_call
    (4) program -> . program variable
    (5) program -> . program token
    (6) program -> . function
    (7) program -> . function_call
    (8) program -> . variable
    (9) program -> . token
    (10) function -> . FN id ( parameter ) { body }
    (11) function -> . COMMAND id ( parameter ) { body }
    (13) function_call -> . id ( term_list )
    (26) variable -> . id = exp
    (12) token -> . TOKEN ( string )
    (51) id -> . ID

    FN              shift and go to state 7
    COMMAND         shift and go to state 9
    TOKEN           shift and go to state 10
    ID              shift and go to state 11

    run                            shift and go to state 1
    program                        shift and go to state 2
    function                       shift and go to state 3
    function_call                  shift and go to state 4
    variable                       shift and go to state 5
    token                          shift and go to state 6
    id                             shift and go to state 8

state 1

    (0) S' -> run .



state 2

    (1) run -> program .
    (2) program -> program . function
    (3) program -> program . function_call
    (4) program -> program . variable
    (5) program -> program . token
    (10) function -> . FN id ( parameter ) { body }
    (11) function -> . COMMAND id ( parameter ) { body }
    (13) function_call -> . id ( term_list )
    (26) variable -> . id = exp
    (12) token -> . TOKEN ( string )
    (51) id -> . ID

    $end            reduce using rule 1 (run -> program .)
    FN              shift and go to state 7
    COMMAND         shift and go to state 9
    TOKEN           shift and go to state 10
    ID              shift and go to state 11

    function                       shift and go to state 12
    function_call                  shift and go to state 13
    variable                       shift and go to state 14
    token                          shift and go to state 15
    id                             shift and go to state 8

state 3

    (6) program -> function .

    FN              reduce using rule 6 (program -> function .)
    COMMAND         reduce using rule 6 (program -> function .)
    TOKEN           reduce using rule 6 (program -> function .)
    ID              reduce using rule 6 (program -> function .)
    $end            reduce using rule 6 (program -> function .)


state 4

    (7) program -> function_call .

    FN              reduce using rule 7 (program -> function_call .)
    COMMAND         reduce using rule 7 (program -> function_call .)
    TOKEN           reduce using rule 7 (program -> function_call .)
    ID              reduce using rule 7 (program -> function_call .)
    $end            reduce using rule 7 (program -> function_call .)


state 5

    (8) program -> variable .

    FN              reduce using rule 8 (program -> variable .)
    COMMAND         reduce using rule 8 (program -> variable .)
    TOKEN           reduce using rule 8 (program -> variable .)
    ID              reduce using rule 8 (program -> variable .)
    $end            reduce using rule 8 (program -> variable .)


state 6

    (9) program -> token .

    FN              reduce using rule 9 (program -> token .)
    COMMAND         reduce using rule 9 (program -> token .)
    TOKEN           reduce using rule 9 (program -> token .)
    ID              reduce using rule 9 (program -> token .)
    $end            reduce using rule 9 (program -> token .)


state 7

    (10) function -> FN . id ( parameter ) { body }
    (51) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 16

state 8

    (13) function_call -> id . ( term_list )
    (26) variable -> id . = exp

    (               shift and go to state 17
    =               shift and go to state 18


state 9

    (11) function -> COMMAND . id ( parameter ) { body }
    (51) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 19

state 10

    (12) token -> TOKEN . ( string )

    (               shift and go to state 20


state 11

    (51) id -> ID .

    (               reduce using rule 51 (id -> ID .)
    =               reduce using rule 51 (id -> ID .)
    )               reduce using rule 51 (id -> ID .)
    ,               reduce using rule 51 (id -> ID .)
    SIGN            reduce using rule 51 (id -> ID .)
    BINARY_OPERATOR reduce using rule 51 (id -> ID .)
    FN              reduce using rule 51 (id -> ID .)
    COMMAND         reduce using rule 51 (id -> ID .)
    TOKEN           reduce using rule 51 (id -> ID .)
    ID              reduce using rule 51 (id -> ID .)
    $end            reduce using rule 51 (id -> ID .)
    }               reduce using rule 51 (id -> ID .)
    IF              reduce using rule 51 (id -> ID .)
    TRY             reduce using rule 51 (id -> ID .)
    UNITARY_OPERATOR reduce using rule 51 (id -> ID .)
    FLOAT           reduce using rule 51 (id -> ID .)
    INTEGER         reduce using rule 51 (id -> ID .)
    BOOLEAN         reduce using rule 51 (id -> ID .)
    STRING          reduce using rule 51 (id -> ID .)
    [               reduce using rule 51 (id -> ID .)
    {               reduce using rule 51 (id -> ID .)
    ]               reduce using rule 51 (id -> ID .)
    :               reduce using rule 51 (id -> ID .)


state 12

    (2) program -> program function .

    FN              reduce using rule 2 (program -> program function .)
    COMMAND         reduce using rule 2 (program -> program function .)
    TOKEN           reduce using rule 2 (program -> program function .)
    ID              reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 13

    (3) program -> program function_call .

    FN              reduce using rule 3 (program -> program function_call .)
    COMMAND         reduce using rule 3 (program -> program function_call .)
    TOKEN           reduce using rule 3 (program -> program function_call .)
    ID              reduce using rule 3 (program -> program function_call .)
    $end            reduce using rule 3 (program -> program function_call .)


state 14

    (4) program -> program variable .

    FN              reduce using rule 4 (program -> program variable .)
    COMMAND         reduce using rule 4 (program -> program variable .)
    TOKEN           reduce using rule 4 (program -> program variable .)
    ID              reduce using rule 4 (program -> program variable .)
    $end            reduce using rule 4 (program -> program variable .)


state 15

    (5) program -> program token .

    FN              reduce using rule 5 (program -> program token .)
    COMMAND         reduce using rule 5 (program -> program token .)
    TOKEN           reduce using rule 5 (program -> program token .)
    ID              reduce using rule 5 (program -> program token .)
    $end            reduce using rule 5 (program -> program token .)


state 16

    (10) function -> FN id . ( parameter ) { body }

    (               shift and go to state 21


state 17

    (13) function_call -> id ( . term_list )
    (29) term_list -> . term_list , term
    (30) term_list -> . term
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    )               reduce using rule 52 (empty -> .)
    ,               reduce using rule 52 (empty -> .)

    id                             shift and go to state 22
    term_list                      shift and go to state 23
    term                           shift and go to state 24
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 18

    (26) variable -> id = . exp
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    FN              reduce using rule 52 (empty -> .)
    COMMAND         reduce using rule 52 (empty -> .)
    TOKEN           reduce using rule 52 (empty -> .)
    $end            reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    id                             shift and go to state 22
    exp                            shift and go to state 41
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 19

    (11) function -> COMMAND id . ( parameter ) { body }

    (               shift and go to state 45


state 20

    (12) token -> TOKEN ( . string )
    (50) string -> . STRING

    STRING          shift and go to state 38

    string                         shift and go to state 46

state 21

    (10) function -> FN id ( . parameter ) { body }
    (14) parameter -> . id , parameter
    (15) parameter -> . id
    (16) parameter -> . empty
    (51) id -> . ID
    (52) empty -> .

    ID              shift and go to state 11
    )               reduce using rule 52 (empty -> .)

    id                             shift and go to state 47
    parameter                      shift and go to state 48
    empty                          shift and go to state 49

state 22

    (36) term -> id .
    (13) function_call -> id . ( term_list )

    )               reduce using rule 36 (term -> id .)
    ,               reduce using rule 36 (term -> id .)
    SIGN            reduce using rule 36 (term -> id .)
    BINARY_OPERATOR reduce using rule 36 (term -> id .)
    FN              reduce using rule 36 (term -> id .)
    COMMAND         reduce using rule 36 (term -> id .)
    TOKEN           reduce using rule 36 (term -> id .)
    ID              reduce using rule 36 (term -> id .)
    $end            reduce using rule 36 (term -> id .)
    }               reduce using rule 36 (term -> id .)
    IF              reduce using rule 36 (term -> id .)
    TRY             reduce using rule 36 (term -> id .)
    UNITARY_OPERATOR reduce using rule 36 (term -> id .)
    FLOAT           reduce using rule 36 (term -> id .)
    INTEGER         reduce using rule 36 (term -> id .)
    BOOLEAN         reduce using rule 36 (term -> id .)
    STRING          reduce using rule 36 (term -> id .)
    [               reduce using rule 36 (term -> id .)
    {               reduce using rule 36 (term -> id .)
    ]               reduce using rule 36 (term -> id .)
    :               reduce using rule 36 (term -> id .)
    (               shift and go to state 17


state 23

    (13) function_call -> id ( term_list . )
    (29) term_list -> term_list . , term

    )               shift and go to state 50
    ,               shift and go to state 51


state 24

    (30) term_list -> term .

    )               reduce using rule 30 (term_list -> term .)
    ,               reduce using rule 30 (term_list -> term .)
    ]               reduce using rule 30 (term_list -> term .)


state 25

    (31) term -> unop . term
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    )               reduce using rule 52 (empty -> .)
    ,               reduce using rule 52 (empty -> .)
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    FN              reduce using rule 52 (empty -> .)
    COMMAND         reduce using rule 52 (empty -> .)
    TOKEN           reduce using rule 52 (empty -> .)
    $end            reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)
    IF              reduce using rule 52 (empty -> .)
    TRY             reduce using rule 52 (empty -> .)
    ]               reduce using rule 52 (empty -> .)
    :               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    unop                           shift and go to state 25
    term                           shift and go to state 52
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 26

    (32) term -> number .

    )               reduce using rule 32 (term -> number .)
    ,               reduce using rule 32 (term -> number .)
    SIGN            reduce using rule 32 (term -> number .)
    BINARY_OPERATOR reduce using rule 32 (term -> number .)
    FN              reduce using rule 32 (term -> number .)
    COMMAND         reduce using rule 32 (term -> number .)
    TOKEN           reduce using rule 32 (term -> number .)
    ID              reduce using rule 32 (term -> number .)
    $end            reduce using rule 32 (term -> number .)
    }               reduce using rule 32 (term -> number .)
    IF              reduce using rule 32 (term -> number .)
    TRY             reduce using rule 32 (term -> number .)
    UNITARY_OPERATOR reduce using rule 32 (term -> number .)
    FLOAT           reduce using rule 32 (term -> number .)
    INTEGER         reduce using rule 32 (term -> number .)
    BOOLEAN         reduce using rule 32 (term -> number .)
    STRING          reduce using rule 32 (term -> number .)
    [               reduce using rule 32 (term -> number .)
    {               reduce using rule 32 (term -> number .)
    ]               reduce using rule 32 (term -> number .)
    :               reduce using rule 32 (term -> number .)


state 27

    (33) term -> boolean .

    )               reduce using rule 33 (term -> boolean .)
    ,               reduce using rule 33 (term -> boolean .)
    SIGN            reduce using rule 33 (term -> boolean .)
    BINARY_OPERATOR reduce using rule 33 (term -> boolean .)
    FN              reduce using rule 33 (term -> boolean .)
    COMMAND         reduce using rule 33 (term -> boolean .)
    TOKEN           reduce using rule 33 (term -> boolean .)
    ID              reduce using rule 33 (term -> boolean .)
    $end            reduce using rule 33 (term -> boolean .)
    }               reduce using rule 33 (term -> boolean .)
    IF              reduce using rule 33 (term -> boolean .)
    TRY             reduce using rule 33 (term -> boolean .)
    UNITARY_OPERATOR reduce using rule 33 (term -> boolean .)
    FLOAT           reduce using rule 33 (term -> boolean .)
    INTEGER         reduce using rule 33 (term -> boolean .)
    BOOLEAN         reduce using rule 33 (term -> boolean .)
    STRING          reduce using rule 33 (term -> boolean .)
    [               reduce using rule 33 (term -> boolean .)
    {               reduce using rule 33 (term -> boolean .)
    ]               reduce using rule 33 (term -> boolean .)
    :               reduce using rule 33 (term -> boolean .)


state 28

    (34) term -> string .

    )               reduce using rule 34 (term -> string .)
    ,               reduce using rule 34 (term -> string .)
    SIGN            reduce using rule 34 (term -> string .)
    BINARY_OPERATOR reduce using rule 34 (term -> string .)
    FN              reduce using rule 34 (term -> string .)
    COMMAND         reduce using rule 34 (term -> string .)
    TOKEN           reduce using rule 34 (term -> string .)
    ID              reduce using rule 34 (term -> string .)
    $end            reduce using rule 34 (term -> string .)
    }               reduce using rule 34 (term -> string .)
    IF              reduce using rule 34 (term -> string .)
    TRY             reduce using rule 34 (term -> string .)
    UNITARY_OPERATOR reduce using rule 34 (term -> string .)
    FLOAT           reduce using rule 34 (term -> string .)
    INTEGER         reduce using rule 34 (term -> string .)
    BOOLEAN         reduce using rule 34 (term -> string .)
    STRING          reduce using rule 34 (term -> string .)
    [               reduce using rule 34 (term -> string .)
    {               reduce using rule 34 (term -> string .)
    ]               reduce using rule 34 (term -> string .)
    :               reduce using rule 34 (term -> string .)


state 29

    (35) term -> function_call .

    )               reduce using rule 35 (term -> function_call .)
    ,               reduce using rule 35 (term -> function_call .)
    SIGN            reduce using rule 35 (term -> function_call .)
    BINARY_OPERATOR reduce using rule 35 (term -> function_call .)
    FN              reduce using rule 35 (term -> function_call .)
    COMMAND         reduce using rule 35 (term -> function_call .)
    TOKEN           reduce using rule 35 (term -> function_call .)
    ID              reduce using rule 35 (term -> function_call .)
    $end            reduce using rule 35 (term -> function_call .)
    }               reduce using rule 35 (term -> function_call .)
    IF              reduce using rule 35 (term -> function_call .)
    TRY             reduce using rule 35 (term -> function_call .)
    UNITARY_OPERATOR reduce using rule 35 (term -> function_call .)
    FLOAT           reduce using rule 35 (term -> function_call .)
    INTEGER         reduce using rule 35 (term -> function_call .)
    BOOLEAN         reduce using rule 35 (term -> function_call .)
    STRING          reduce using rule 35 (term -> function_call .)
    [               reduce using rule 35 (term -> function_call .)
    {               reduce using rule 35 (term -> function_call .)
    ]               reduce using rule 35 (term -> function_call .)
    :               reduce using rule 35 (term -> function_call .)


state 30

    (37) term -> list .

    )               reduce using rule 37 (term -> list .)
    ,               reduce using rule 37 (term -> list .)
    SIGN            reduce using rule 37 (term -> list .)
    BINARY_OPERATOR reduce using rule 37 (term -> list .)
    FN              reduce using rule 37 (term -> list .)
    COMMAND         reduce using rule 37 (term -> list .)
    TOKEN           reduce using rule 37 (term -> list .)
    ID              reduce using rule 37 (term -> list .)
    $end            reduce using rule 37 (term -> list .)
    }               reduce using rule 37 (term -> list .)
    IF              reduce using rule 37 (term -> list .)
    TRY             reduce using rule 37 (term -> list .)
    UNITARY_OPERATOR reduce using rule 37 (term -> list .)
    FLOAT           reduce using rule 37 (term -> list .)
    INTEGER         reduce using rule 37 (term -> list .)
    BOOLEAN         reduce using rule 37 (term -> list .)
    STRING          reduce using rule 37 (term -> list .)
    [               reduce using rule 37 (term -> list .)
    {               reduce using rule 37 (term -> list .)
    ]               reduce using rule 37 (term -> list .)
    :               reduce using rule 37 (term -> list .)


state 31

    (38) term -> dict .

    )               reduce using rule 38 (term -> dict .)
    ,               reduce using rule 38 (term -> dict .)
    SIGN            reduce using rule 38 (term -> dict .)
    BINARY_OPERATOR reduce using rule 38 (term -> dict .)
    FN              reduce using rule 38 (term -> dict .)
    COMMAND         reduce using rule 38 (term -> dict .)
    TOKEN           reduce using rule 38 (term -> dict .)
    ID              reduce using rule 38 (term -> dict .)
    $end            reduce using rule 38 (term -> dict .)
    }               reduce using rule 38 (term -> dict .)
    IF              reduce using rule 38 (term -> dict .)
    TRY             reduce using rule 38 (term -> dict .)
    UNITARY_OPERATOR reduce using rule 38 (term -> dict .)
    FLOAT           reduce using rule 38 (term -> dict .)
    INTEGER         reduce using rule 38 (term -> dict .)
    BOOLEAN         reduce using rule 38 (term -> dict .)
    STRING          reduce using rule 38 (term -> dict .)
    [               reduce using rule 38 (term -> dict .)
    {               reduce using rule 38 (term -> dict .)
    ]               reduce using rule 38 (term -> dict .)
    :               reduce using rule 38 (term -> dict .)


state 32

    (39) term -> empty .

    )               reduce using rule 39 (term -> empty .)
    ,               reduce using rule 39 (term -> empty .)
    SIGN            reduce using rule 39 (term -> empty .)
    BINARY_OPERATOR reduce using rule 39 (term -> empty .)
    FN              reduce using rule 39 (term -> empty .)
    COMMAND         reduce using rule 39 (term -> empty .)
    TOKEN           reduce using rule 39 (term -> empty .)
    ID              reduce using rule 39 (term -> empty .)
    $end            reduce using rule 39 (term -> empty .)
    }               reduce using rule 39 (term -> empty .)
    IF              reduce using rule 39 (term -> empty .)
    TRY             reduce using rule 39 (term -> empty .)
    UNITARY_OPERATOR reduce using rule 39 (term -> empty .)
    FLOAT           reduce using rule 39 (term -> empty .)
    INTEGER         reduce using rule 39 (term -> empty .)
    BOOLEAN         reduce using rule 39 (term -> empty .)
    STRING          reduce using rule 39 (term -> empty .)
    [               reduce using rule 39 (term -> empty .)
    {               reduce using rule 39 (term -> empty .)
    ]               reduce using rule 39 (term -> empty .)
    :               reduce using rule 39 (term -> empty .)


state 33

    (40) unop -> SIGN .

    SIGN            reduce using rule 40 (unop -> SIGN .)
    UNITARY_OPERATOR reduce using rule 40 (unop -> SIGN .)
    FLOAT           reduce using rule 40 (unop -> SIGN .)
    INTEGER         reduce using rule 40 (unop -> SIGN .)
    BOOLEAN         reduce using rule 40 (unop -> SIGN .)
    STRING          reduce using rule 40 (unop -> SIGN .)
    ID              reduce using rule 40 (unop -> SIGN .)
    [               reduce using rule 40 (unop -> SIGN .)
    {               reduce using rule 40 (unop -> SIGN .)
    )               reduce using rule 40 (unop -> SIGN .)
    ,               reduce using rule 40 (unop -> SIGN .)
    BINARY_OPERATOR reduce using rule 40 (unop -> SIGN .)
    FN              reduce using rule 40 (unop -> SIGN .)
    COMMAND         reduce using rule 40 (unop -> SIGN .)
    TOKEN           reduce using rule 40 (unop -> SIGN .)
    $end            reduce using rule 40 (unop -> SIGN .)
    }               reduce using rule 40 (unop -> SIGN .)
    IF              reduce using rule 40 (unop -> SIGN .)
    TRY             reduce using rule 40 (unop -> SIGN .)
    ]               reduce using rule 40 (unop -> SIGN .)
    :               reduce using rule 40 (unop -> SIGN .)


state 34

    (41) unop -> UNITARY_OPERATOR .

    SIGN            reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    UNITARY_OPERATOR reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    FLOAT           reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    INTEGER         reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    BOOLEAN         reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    STRING          reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    ID              reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    [               reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    {               reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    )               reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    ,               reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    BINARY_OPERATOR reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    FN              reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    COMMAND         reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    TOKEN           reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    $end            reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    }               reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    IF              reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    TRY             reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    ]               reduce using rule 41 (unop -> UNITARY_OPERATOR .)
    :               reduce using rule 41 (unop -> UNITARY_OPERATOR .)


state 35

    (47) number -> FLOAT .

    )               reduce using rule 47 (number -> FLOAT .)
    ,               reduce using rule 47 (number -> FLOAT .)
    SIGN            reduce using rule 47 (number -> FLOAT .)
    BINARY_OPERATOR reduce using rule 47 (number -> FLOAT .)
    FN              reduce using rule 47 (number -> FLOAT .)
    COMMAND         reduce using rule 47 (number -> FLOAT .)
    TOKEN           reduce using rule 47 (number -> FLOAT .)
    ID              reduce using rule 47 (number -> FLOAT .)
    $end            reduce using rule 47 (number -> FLOAT .)
    }               reduce using rule 47 (number -> FLOAT .)
    IF              reduce using rule 47 (number -> FLOAT .)
    TRY             reduce using rule 47 (number -> FLOAT .)
    UNITARY_OPERATOR reduce using rule 47 (number -> FLOAT .)
    FLOAT           reduce using rule 47 (number -> FLOAT .)
    INTEGER         reduce using rule 47 (number -> FLOAT .)
    BOOLEAN         reduce using rule 47 (number -> FLOAT .)
    STRING          reduce using rule 47 (number -> FLOAT .)
    [               reduce using rule 47 (number -> FLOAT .)
    {               reduce using rule 47 (number -> FLOAT .)
    ]               reduce using rule 47 (number -> FLOAT .)
    :               reduce using rule 47 (number -> FLOAT .)


state 36

    (48) number -> INTEGER .

    )               reduce using rule 48 (number -> INTEGER .)
    ,               reduce using rule 48 (number -> INTEGER .)
    SIGN            reduce using rule 48 (number -> INTEGER .)
    BINARY_OPERATOR reduce using rule 48 (number -> INTEGER .)
    FN              reduce using rule 48 (number -> INTEGER .)
    COMMAND         reduce using rule 48 (number -> INTEGER .)
    TOKEN           reduce using rule 48 (number -> INTEGER .)
    ID              reduce using rule 48 (number -> INTEGER .)
    $end            reduce using rule 48 (number -> INTEGER .)
    }               reduce using rule 48 (number -> INTEGER .)
    IF              reduce using rule 48 (number -> INTEGER .)
    TRY             reduce using rule 48 (number -> INTEGER .)
    UNITARY_OPERATOR reduce using rule 48 (number -> INTEGER .)
    FLOAT           reduce using rule 48 (number -> INTEGER .)
    INTEGER         reduce using rule 48 (number -> INTEGER .)
    BOOLEAN         reduce using rule 48 (number -> INTEGER .)
    STRING          reduce using rule 48 (number -> INTEGER .)
    [               reduce using rule 48 (number -> INTEGER .)
    {               reduce using rule 48 (number -> INTEGER .)
    ]               reduce using rule 48 (number -> INTEGER .)
    :               reduce using rule 48 (number -> INTEGER .)


state 37

    (49) boolean -> BOOLEAN .

    )               reduce using rule 49 (boolean -> BOOLEAN .)
    ,               reduce using rule 49 (boolean -> BOOLEAN .)
    SIGN            reduce using rule 49 (boolean -> BOOLEAN .)
    BINARY_OPERATOR reduce using rule 49 (boolean -> BOOLEAN .)
    FN              reduce using rule 49 (boolean -> BOOLEAN .)
    COMMAND         reduce using rule 49 (boolean -> BOOLEAN .)
    TOKEN           reduce using rule 49 (boolean -> BOOLEAN .)
    ID              reduce using rule 49 (boolean -> BOOLEAN .)
    $end            reduce using rule 49 (boolean -> BOOLEAN .)
    }               reduce using rule 49 (boolean -> BOOLEAN .)
    IF              reduce using rule 49 (boolean -> BOOLEAN .)
    TRY             reduce using rule 49 (boolean -> BOOLEAN .)
    UNITARY_OPERATOR reduce using rule 49 (boolean -> BOOLEAN .)
    FLOAT           reduce using rule 49 (boolean -> BOOLEAN .)
    INTEGER         reduce using rule 49 (boolean -> BOOLEAN .)
    BOOLEAN         reduce using rule 49 (boolean -> BOOLEAN .)
    STRING          reduce using rule 49 (boolean -> BOOLEAN .)
    [               reduce using rule 49 (boolean -> BOOLEAN .)
    {               reduce using rule 49 (boolean -> BOOLEAN .)
    ]               reduce using rule 49 (boolean -> BOOLEAN .)
    :               reduce using rule 49 (boolean -> BOOLEAN .)


state 38

    (50) string -> STRING .

    )               reduce using rule 50 (string -> STRING .)
    ,               reduce using rule 50 (string -> STRING .)
    SIGN            reduce using rule 50 (string -> STRING .)
    BINARY_OPERATOR reduce using rule 50 (string -> STRING .)
    FN              reduce using rule 50 (string -> STRING .)
    COMMAND         reduce using rule 50 (string -> STRING .)
    TOKEN           reduce using rule 50 (string -> STRING .)
    ID              reduce using rule 50 (string -> STRING .)
    $end            reduce using rule 50 (string -> STRING .)
    }               reduce using rule 50 (string -> STRING .)
    IF              reduce using rule 50 (string -> STRING .)
    TRY             reduce using rule 50 (string -> STRING .)
    UNITARY_OPERATOR reduce using rule 50 (string -> STRING .)
    FLOAT           reduce using rule 50 (string -> STRING .)
    INTEGER         reduce using rule 50 (string -> STRING .)
    BOOLEAN         reduce using rule 50 (string -> STRING .)
    STRING          reduce using rule 50 (string -> STRING .)
    [               reduce using rule 50 (string -> STRING .)
    {               reduce using rule 50 (string -> STRING .)
    ]               reduce using rule 50 (string -> STRING .)
    :               reduce using rule 50 (string -> STRING .)


state 39

    (46) list -> [ . term_list ]
    (29) term_list -> . term_list , term
    (30) term_list -> . term
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    ]               reduce using rule 52 (empty -> .)
    ,               reduce using rule 52 (empty -> .)

    term_list                      shift and go to state 53
    term                           shift and go to state 24
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 40

    (44) dict -> { . term_map }
    (45) dict -> { . empty }
    (27) term_map -> . term : term , term_map
    (28) term_map -> . term : term
    (52) empty -> .
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }

    }               reduce using rule 52 (empty -> .)
    :               reduce using rule 52 (empty -> .)
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40

    term_map                       shift and go to state 54
    empty                          shift and go to state 55
    term                           shift and go to state 56
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31

state 41

    (26) variable -> id = exp .

    FN              reduce using rule 26 (variable -> id = exp .)
    COMMAND         reduce using rule 26 (variable -> id = exp .)
    TOKEN           reduce using rule 26 (variable -> id = exp .)
    ID              reduce using rule 26 (variable -> id = exp .)
    $end            reduce using rule 26 (variable -> id = exp .)
    }               reduce using rule 26 (variable -> id = exp .)
    IF              reduce using rule 26 (variable -> id = exp .)
    TRY             reduce using rule 26 (variable -> id = exp .)
    SIGN            reduce using rule 26 (variable -> id = exp .)
    UNITARY_OPERATOR reduce using rule 26 (variable -> id = exp .)
    FLOAT           reduce using rule 26 (variable -> id = exp .)
    INTEGER         reduce using rule 26 (variable -> id = exp .)
    BOOLEAN         reduce using rule 26 (variable -> id = exp .)
    STRING          reduce using rule 26 (variable -> id = exp .)
    [               reduce using rule 26 (variable -> id = exp .)
    {               reduce using rule 26 (variable -> id = exp .)
    BINARY_OPERATOR reduce using rule 26 (variable -> id = exp .)


state 42

    (21) exp -> term . binop exp
    (22) exp -> term .
    (42) binop -> . SIGN
    (43) binop -> . BINARY_OPERATOR

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for BINARY_OPERATOR resolved as shift
    FN              reduce using rule 22 (exp -> term .)
    COMMAND         reduce using rule 22 (exp -> term .)
    TOKEN           reduce using rule 22 (exp -> term .)
    ID              reduce using rule 22 (exp -> term .)
    $end            reduce using rule 22 (exp -> term .)
    }               reduce using rule 22 (exp -> term .)
    IF              reduce using rule 22 (exp -> term .)
    TRY             reduce using rule 22 (exp -> term .)
    UNITARY_OPERATOR reduce using rule 22 (exp -> term .)
    FLOAT           reduce using rule 22 (exp -> term .)
    INTEGER         reduce using rule 22 (exp -> term .)
    BOOLEAN         reduce using rule 22 (exp -> term .)
    STRING          reduce using rule 22 (exp -> term .)
    [               reduce using rule 22 (exp -> term .)
    {               reduce using rule 22 (exp -> term .)
    SIGN            shift and go to state 58
    BINARY_OPERATOR shift and go to state 59

  ! SIGN            [ reduce using rule 22 (exp -> term .) ]
  ! BINARY_OPERATOR [ reduce using rule 22 (exp -> term .) ]

    binop                          shift and go to state 57

state 43

    (23) exp -> IF . exp { body } ELSE { body }
    (24) exp -> IF . exp { body }
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    exp                            shift and go to state 60
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 44

    (25) exp -> TRY . { body } CATCH { body }

    {               shift and go to state 61


state 45

    (11) function -> COMMAND id ( . parameter ) { body }
    (14) parameter -> . id , parameter
    (15) parameter -> . id
    (16) parameter -> . empty
    (51) id -> . ID
    (52) empty -> .

    ID              shift and go to state 11
    )               reduce using rule 52 (empty -> .)

    id                             shift and go to state 47
    parameter                      shift and go to state 62
    empty                          shift and go to state 49

state 46

    (12) token -> TOKEN ( string . )

    )               shift and go to state 63


state 47

    (14) parameter -> id . , parameter
    (15) parameter -> id .

    ,               shift and go to state 64
    )               reduce using rule 15 (parameter -> id .)


state 48

    (10) function -> FN id ( parameter . ) { body }

    )               shift and go to state 65


state 49

    (16) parameter -> empty .

    )               reduce using rule 16 (parameter -> empty .)


state 50

    (13) function_call -> id ( term_list ) .

    FN              reduce using rule 13 (function_call -> id ( term_list ) .)
    COMMAND         reduce using rule 13 (function_call -> id ( term_list ) .)
    TOKEN           reduce using rule 13 (function_call -> id ( term_list ) .)
    ID              reduce using rule 13 (function_call -> id ( term_list ) .)
    $end            reduce using rule 13 (function_call -> id ( term_list ) .)
    )               reduce using rule 13 (function_call -> id ( term_list ) .)
    ,               reduce using rule 13 (function_call -> id ( term_list ) .)
    SIGN            reduce using rule 13 (function_call -> id ( term_list ) .)
    BINARY_OPERATOR reduce using rule 13 (function_call -> id ( term_list ) .)
    }               reduce using rule 13 (function_call -> id ( term_list ) .)
    IF              reduce using rule 13 (function_call -> id ( term_list ) .)
    TRY             reduce using rule 13 (function_call -> id ( term_list ) .)
    UNITARY_OPERATOR reduce using rule 13 (function_call -> id ( term_list ) .)
    FLOAT           reduce using rule 13 (function_call -> id ( term_list ) .)
    INTEGER         reduce using rule 13 (function_call -> id ( term_list ) .)
    BOOLEAN         reduce using rule 13 (function_call -> id ( term_list ) .)
    STRING          reduce using rule 13 (function_call -> id ( term_list ) .)
    [               reduce using rule 13 (function_call -> id ( term_list ) .)
    {               reduce using rule 13 (function_call -> id ( term_list ) .)
    ]               reduce using rule 13 (function_call -> id ( term_list ) .)
    :               reduce using rule 13 (function_call -> id ( term_list ) .)


state 51

    (29) term_list -> term_list , . term
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    )               reduce using rule 52 (empty -> .)
    ,               reduce using rule 52 (empty -> .)
    ]               reduce using rule 52 (empty -> .)

    term                           shift and go to state 66
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 52

    (31) term -> unop term .

    )               reduce using rule 31 (term -> unop term .)
    ,               reduce using rule 31 (term -> unop term .)
    SIGN            reduce using rule 31 (term -> unop term .)
    BINARY_OPERATOR reduce using rule 31 (term -> unop term .)
    FN              reduce using rule 31 (term -> unop term .)
    COMMAND         reduce using rule 31 (term -> unop term .)
    TOKEN           reduce using rule 31 (term -> unop term .)
    ID              reduce using rule 31 (term -> unop term .)
    $end            reduce using rule 31 (term -> unop term .)
    }               reduce using rule 31 (term -> unop term .)
    IF              reduce using rule 31 (term -> unop term .)
    TRY             reduce using rule 31 (term -> unop term .)
    UNITARY_OPERATOR reduce using rule 31 (term -> unop term .)
    FLOAT           reduce using rule 31 (term -> unop term .)
    INTEGER         reduce using rule 31 (term -> unop term .)
    BOOLEAN         reduce using rule 31 (term -> unop term .)
    STRING          reduce using rule 31 (term -> unop term .)
    [               reduce using rule 31 (term -> unop term .)
    {               reduce using rule 31 (term -> unop term .)
    ]               reduce using rule 31 (term -> unop term .)
    :               reduce using rule 31 (term -> unop term .)


state 53

    (46) list -> [ term_list . ]
    (29) term_list -> term_list . , term

    ]               shift and go to state 67
    ,               shift and go to state 51


state 54

    (44) dict -> { term_map . }

    }               shift and go to state 68


state 55

    (45) dict -> { empty . }
    (39) term -> empty .

    }               shift and go to state 69
    :               reduce using rule 39 (term -> empty .)


state 56

    (27) term_map -> term . : term , term_map
    (28) term_map -> term . : term

    :               shift and go to state 70


state 57

    (21) exp -> term binop . exp
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    FN              reduce using rule 52 (empty -> .)
    COMMAND         reduce using rule 52 (empty -> .)
    TOKEN           reduce using rule 52 (empty -> .)
    $end            reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    term                           shift and go to state 42
    exp                            shift and go to state 71
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 58

    (42) binop -> SIGN .

    IF              reduce using rule 42 (binop -> SIGN .)
    TRY             reduce using rule 42 (binop -> SIGN .)
    SIGN            reduce using rule 42 (binop -> SIGN .)
    UNITARY_OPERATOR reduce using rule 42 (binop -> SIGN .)
    FLOAT           reduce using rule 42 (binop -> SIGN .)
    INTEGER         reduce using rule 42 (binop -> SIGN .)
    BOOLEAN         reduce using rule 42 (binop -> SIGN .)
    STRING          reduce using rule 42 (binop -> SIGN .)
    ID              reduce using rule 42 (binop -> SIGN .)
    [               reduce using rule 42 (binop -> SIGN .)
    {               reduce using rule 42 (binop -> SIGN .)
    BINARY_OPERATOR reduce using rule 42 (binop -> SIGN .)
    FN              reduce using rule 42 (binop -> SIGN .)
    COMMAND         reduce using rule 42 (binop -> SIGN .)
    TOKEN           reduce using rule 42 (binop -> SIGN .)
    $end            reduce using rule 42 (binop -> SIGN .)
    }               reduce using rule 42 (binop -> SIGN .)


state 59

    (43) binop -> BINARY_OPERATOR .

    IF              reduce using rule 43 (binop -> BINARY_OPERATOR .)
    TRY             reduce using rule 43 (binop -> BINARY_OPERATOR .)
    SIGN            reduce using rule 43 (binop -> BINARY_OPERATOR .)
    UNITARY_OPERATOR reduce using rule 43 (binop -> BINARY_OPERATOR .)
    FLOAT           reduce using rule 43 (binop -> BINARY_OPERATOR .)
    INTEGER         reduce using rule 43 (binop -> BINARY_OPERATOR .)
    BOOLEAN         reduce using rule 43 (binop -> BINARY_OPERATOR .)
    STRING          reduce using rule 43 (binop -> BINARY_OPERATOR .)
    ID              reduce using rule 43 (binop -> BINARY_OPERATOR .)
    [               reduce using rule 43 (binop -> BINARY_OPERATOR .)
    {               reduce using rule 43 (binop -> BINARY_OPERATOR .)
    BINARY_OPERATOR reduce using rule 43 (binop -> BINARY_OPERATOR .)
    FN              reduce using rule 43 (binop -> BINARY_OPERATOR .)
    COMMAND         reduce using rule 43 (binop -> BINARY_OPERATOR .)
    TOKEN           reduce using rule 43 (binop -> BINARY_OPERATOR .)
    $end            reduce using rule 43 (binop -> BINARY_OPERATOR .)
    }               reduce using rule 43 (binop -> BINARY_OPERATOR .)


state 60

    (23) exp -> IF exp . { body } ELSE { body }
    (24) exp -> IF exp . { body }

    {               shift and go to state 72


state 61

    (25) exp -> TRY { . body } CATCH { body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . exp
    (20) body -> . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    body                           shift and go to state 73
    exp                            shift and go to state 74
    variable                       shift and go to state 75
    term                           shift and go to state 42
    id                             shift and go to state 76
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 62

    (11) function -> COMMAND id ( parameter . ) { body }

    )               shift and go to state 77


state 63

    (12) token -> TOKEN ( string ) .

    FN              reduce using rule 12 (token -> TOKEN ( string ) .)
    COMMAND         reduce using rule 12 (token -> TOKEN ( string ) .)
    TOKEN           reduce using rule 12 (token -> TOKEN ( string ) .)
    ID              reduce using rule 12 (token -> TOKEN ( string ) .)
    $end            reduce using rule 12 (token -> TOKEN ( string ) .)


state 64

    (14) parameter -> id , . parameter
    (14) parameter -> . id , parameter
    (15) parameter -> . id
    (16) parameter -> . empty
    (51) id -> . ID
    (52) empty -> .

    ID              shift and go to state 11
    )               reduce using rule 52 (empty -> .)

    id                             shift and go to state 47
    parameter                      shift and go to state 78
    empty                          shift and go to state 49

state 65

    (10) function -> FN id ( parameter ) . { body }

    {               shift and go to state 79


state 66

    (29) term_list -> term_list , term .

    )               reduce using rule 29 (term_list -> term_list , term .)
    ,               reduce using rule 29 (term_list -> term_list , term .)
    ]               reduce using rule 29 (term_list -> term_list , term .)


state 67

    (46) list -> [ term_list ] .

    )               reduce using rule 46 (list -> [ term_list ] .)
    ,               reduce using rule 46 (list -> [ term_list ] .)
    SIGN            reduce using rule 46 (list -> [ term_list ] .)
    BINARY_OPERATOR reduce using rule 46 (list -> [ term_list ] .)
    FN              reduce using rule 46 (list -> [ term_list ] .)
    COMMAND         reduce using rule 46 (list -> [ term_list ] .)
    TOKEN           reduce using rule 46 (list -> [ term_list ] .)
    ID              reduce using rule 46 (list -> [ term_list ] .)
    $end            reduce using rule 46 (list -> [ term_list ] .)
    }               reduce using rule 46 (list -> [ term_list ] .)
    IF              reduce using rule 46 (list -> [ term_list ] .)
    TRY             reduce using rule 46 (list -> [ term_list ] .)
    UNITARY_OPERATOR reduce using rule 46 (list -> [ term_list ] .)
    FLOAT           reduce using rule 46 (list -> [ term_list ] .)
    INTEGER         reduce using rule 46 (list -> [ term_list ] .)
    BOOLEAN         reduce using rule 46 (list -> [ term_list ] .)
    STRING          reduce using rule 46 (list -> [ term_list ] .)
    [               reduce using rule 46 (list -> [ term_list ] .)
    {               reduce using rule 46 (list -> [ term_list ] .)
    ]               reduce using rule 46 (list -> [ term_list ] .)
    :               reduce using rule 46 (list -> [ term_list ] .)


state 68

    (44) dict -> { term_map } .

    )               reduce using rule 44 (dict -> { term_map } .)
    ,               reduce using rule 44 (dict -> { term_map } .)
    SIGN            reduce using rule 44 (dict -> { term_map } .)
    BINARY_OPERATOR reduce using rule 44 (dict -> { term_map } .)
    FN              reduce using rule 44 (dict -> { term_map } .)
    COMMAND         reduce using rule 44 (dict -> { term_map } .)
    TOKEN           reduce using rule 44 (dict -> { term_map } .)
    ID              reduce using rule 44 (dict -> { term_map } .)
    $end            reduce using rule 44 (dict -> { term_map } .)
    }               reduce using rule 44 (dict -> { term_map } .)
    IF              reduce using rule 44 (dict -> { term_map } .)
    TRY             reduce using rule 44 (dict -> { term_map } .)
    UNITARY_OPERATOR reduce using rule 44 (dict -> { term_map } .)
    FLOAT           reduce using rule 44 (dict -> { term_map } .)
    INTEGER         reduce using rule 44 (dict -> { term_map } .)
    BOOLEAN         reduce using rule 44 (dict -> { term_map } .)
    STRING          reduce using rule 44 (dict -> { term_map } .)
    [               reduce using rule 44 (dict -> { term_map } .)
    {               reduce using rule 44 (dict -> { term_map } .)
    ]               reduce using rule 44 (dict -> { term_map } .)
    :               reduce using rule 44 (dict -> { term_map } .)


state 69

    (45) dict -> { empty } .

    )               reduce using rule 45 (dict -> { empty } .)
    ,               reduce using rule 45 (dict -> { empty } .)
    SIGN            reduce using rule 45 (dict -> { empty } .)
    BINARY_OPERATOR reduce using rule 45 (dict -> { empty } .)
    FN              reduce using rule 45 (dict -> { empty } .)
    COMMAND         reduce using rule 45 (dict -> { empty } .)
    TOKEN           reduce using rule 45 (dict -> { empty } .)
    ID              reduce using rule 45 (dict -> { empty } .)
    $end            reduce using rule 45 (dict -> { empty } .)
    }               reduce using rule 45 (dict -> { empty } .)
    IF              reduce using rule 45 (dict -> { empty } .)
    TRY             reduce using rule 45 (dict -> { empty } .)
    UNITARY_OPERATOR reduce using rule 45 (dict -> { empty } .)
    FLOAT           reduce using rule 45 (dict -> { empty } .)
    INTEGER         reduce using rule 45 (dict -> { empty } .)
    BOOLEAN         reduce using rule 45 (dict -> { empty } .)
    STRING          reduce using rule 45 (dict -> { empty } .)
    [               reduce using rule 45 (dict -> { empty } .)
    {               reduce using rule 45 (dict -> { empty } .)
    ]               reduce using rule 45 (dict -> { empty } .)
    :               reduce using rule 45 (dict -> { empty } .)


state 70

    (27) term_map -> term : . term , term_map
    (28) term_map -> term : . term
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    ,               reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

    term                           shift and go to state 80
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 71

    (21) exp -> term binop exp .

    FN              reduce using rule 21 (exp -> term binop exp .)
    COMMAND         reduce using rule 21 (exp -> term binop exp .)
    TOKEN           reduce using rule 21 (exp -> term binop exp .)
    ID              reduce using rule 21 (exp -> term binop exp .)
    $end            reduce using rule 21 (exp -> term binop exp .)
    }               reduce using rule 21 (exp -> term binop exp .)
    IF              reduce using rule 21 (exp -> term binop exp .)
    TRY             reduce using rule 21 (exp -> term binop exp .)
    SIGN            reduce using rule 21 (exp -> term binop exp .)
    UNITARY_OPERATOR reduce using rule 21 (exp -> term binop exp .)
    FLOAT           reduce using rule 21 (exp -> term binop exp .)
    INTEGER         reduce using rule 21 (exp -> term binop exp .)
    BOOLEAN         reduce using rule 21 (exp -> term binop exp .)
    STRING          reduce using rule 21 (exp -> term binop exp .)
    [               reduce using rule 21 (exp -> term binop exp .)
    {               reduce using rule 21 (exp -> term binop exp .)
    BINARY_OPERATOR reduce using rule 21 (exp -> term binop exp .)


state 72

    (23) exp -> IF exp { . body } ELSE { body }
    (24) exp -> IF exp { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . exp
    (20) body -> . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    exp                            shift and go to state 74
    body                           shift and go to state 81
    variable                       shift and go to state 75
    term                           shift and go to state 42
    id                             shift and go to state 76
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 73

    (25) exp -> TRY { body . } CATCH { body }
    (17) body -> body . exp
    (18) body -> body . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 82
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! }               [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    exp                            shift and go to state 83
    variable                       shift and go to state 84
    term                           shift and go to state 42
    id                             shift and go to state 76
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 74

    (19) body -> exp .

    }               reduce using rule 19 (body -> exp .)
    IF              reduce using rule 19 (body -> exp .)
    TRY             reduce using rule 19 (body -> exp .)
    ID              reduce using rule 19 (body -> exp .)
    SIGN            reduce using rule 19 (body -> exp .)
    UNITARY_OPERATOR reduce using rule 19 (body -> exp .)
    FLOAT           reduce using rule 19 (body -> exp .)
    INTEGER         reduce using rule 19 (body -> exp .)
    BOOLEAN         reduce using rule 19 (body -> exp .)
    STRING          reduce using rule 19 (body -> exp .)
    [               reduce using rule 19 (body -> exp .)
    {               reduce using rule 19 (body -> exp .)
    BINARY_OPERATOR reduce using rule 19 (body -> exp .)


state 75

    (20) body -> variable .

    }               reduce using rule 20 (body -> variable .)
    IF              reduce using rule 20 (body -> variable .)
    TRY             reduce using rule 20 (body -> variable .)
    ID              reduce using rule 20 (body -> variable .)
    SIGN            reduce using rule 20 (body -> variable .)
    UNITARY_OPERATOR reduce using rule 20 (body -> variable .)
    FLOAT           reduce using rule 20 (body -> variable .)
    INTEGER         reduce using rule 20 (body -> variable .)
    BOOLEAN         reduce using rule 20 (body -> variable .)
    STRING          reduce using rule 20 (body -> variable .)
    [               reduce using rule 20 (body -> variable .)
    {               reduce using rule 20 (body -> variable .)
    BINARY_OPERATOR reduce using rule 20 (body -> variable .)


state 76

    (26) variable -> id . = exp
    (36) term -> id .
    (13) function_call -> id . ( term_list )

    =               shift and go to state 18
    SIGN            reduce using rule 36 (term -> id .)
    BINARY_OPERATOR reduce using rule 36 (term -> id .)
    }               reduce using rule 36 (term -> id .)
    IF              reduce using rule 36 (term -> id .)
    TRY             reduce using rule 36 (term -> id .)
    ID              reduce using rule 36 (term -> id .)
    UNITARY_OPERATOR reduce using rule 36 (term -> id .)
    FLOAT           reduce using rule 36 (term -> id .)
    INTEGER         reduce using rule 36 (term -> id .)
    BOOLEAN         reduce using rule 36 (term -> id .)
    STRING          reduce using rule 36 (term -> id .)
    [               reduce using rule 36 (term -> id .)
    {               reduce using rule 36 (term -> id .)
    (               shift and go to state 17


state 77

    (11) function -> COMMAND id ( parameter ) . { body }

    {               shift and go to state 85


state 78

    (14) parameter -> id , parameter .

    )               reduce using rule 14 (parameter -> id , parameter .)


state 79

    (10) function -> FN id ( parameter ) { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . exp
    (20) body -> . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    id                             shift and go to state 76
    body                           shift and go to state 86
    exp                            shift and go to state 74
    variable                       shift and go to state 75
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 80

    (27) term_map -> term : term . , term_map
    (28) term_map -> term : term .

    ,               shift and go to state 87
    }               reduce using rule 28 (term_map -> term : term .)


state 81

    (23) exp -> IF exp { body . } ELSE { body }
    (24) exp -> IF exp { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 88
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! }               [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    exp                            shift and go to state 83
    variable                       shift and go to state 84
    term                           shift and go to state 42
    id                             shift and go to state 76
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 82

    (25) exp -> TRY { body } . CATCH { body }

    CATCH           shift and go to state 89


state 83

    (17) body -> body exp .

    }               reduce using rule 17 (body -> body exp .)
    IF              reduce using rule 17 (body -> body exp .)
    TRY             reduce using rule 17 (body -> body exp .)
    ID              reduce using rule 17 (body -> body exp .)
    SIGN            reduce using rule 17 (body -> body exp .)
    UNITARY_OPERATOR reduce using rule 17 (body -> body exp .)
    FLOAT           reduce using rule 17 (body -> body exp .)
    INTEGER         reduce using rule 17 (body -> body exp .)
    BOOLEAN         reduce using rule 17 (body -> body exp .)
    STRING          reduce using rule 17 (body -> body exp .)
    [               reduce using rule 17 (body -> body exp .)
    {               reduce using rule 17 (body -> body exp .)
    BINARY_OPERATOR reduce using rule 17 (body -> body exp .)


state 84

    (18) body -> body variable .

    }               reduce using rule 18 (body -> body variable .)
    IF              reduce using rule 18 (body -> body variable .)
    TRY             reduce using rule 18 (body -> body variable .)
    ID              reduce using rule 18 (body -> body variable .)
    SIGN            reduce using rule 18 (body -> body variable .)
    UNITARY_OPERATOR reduce using rule 18 (body -> body variable .)
    FLOAT           reduce using rule 18 (body -> body variable .)
    INTEGER         reduce using rule 18 (body -> body variable .)
    BOOLEAN         reduce using rule 18 (body -> body variable .)
    STRING          reduce using rule 18 (body -> body variable .)
    [               reduce using rule 18 (body -> body variable .)
    {               reduce using rule 18 (body -> body variable .)
    BINARY_OPERATOR reduce using rule 18 (body -> body variable .)


state 85

    (11) function -> COMMAND id ( parameter ) { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . exp
    (20) body -> . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    id                             shift and go to state 76
    body                           shift and go to state 90
    exp                            shift and go to state 74
    variable                       shift and go to state 75
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 86

    (10) function -> FN id ( parameter ) { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 91
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! }               [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    id                             shift and go to state 76
    exp                            shift and go to state 83
    variable                       shift and go to state 84
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 87

    (27) term_map -> term : term , . term_map
    (27) term_map -> . term : term , term_map
    (28) term_map -> . term : term
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (51) id -> . ID
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    :               reduce using rule 52 (empty -> .)

    term                           shift and go to state 56
    term_map                       shift and go to state 92
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 88

    (23) exp -> IF exp { body } . ELSE { body }
    (24) exp -> IF exp { body } .

    ELSE            shift and go to state 93
    FN              reduce using rule 24 (exp -> IF exp { body } .)
    COMMAND         reduce using rule 24 (exp -> IF exp { body } .)
    TOKEN           reduce using rule 24 (exp -> IF exp { body } .)
    ID              reduce using rule 24 (exp -> IF exp { body } .)
    $end            reduce using rule 24 (exp -> IF exp { body } .)
    }               reduce using rule 24 (exp -> IF exp { body } .)
    IF              reduce using rule 24 (exp -> IF exp { body } .)
    TRY             reduce using rule 24 (exp -> IF exp { body } .)
    SIGN            reduce using rule 24 (exp -> IF exp { body } .)
    UNITARY_OPERATOR reduce using rule 24 (exp -> IF exp { body } .)
    FLOAT           reduce using rule 24 (exp -> IF exp { body } .)
    INTEGER         reduce using rule 24 (exp -> IF exp { body } .)
    BOOLEAN         reduce using rule 24 (exp -> IF exp { body } .)
    STRING          reduce using rule 24 (exp -> IF exp { body } .)
    [               reduce using rule 24 (exp -> IF exp { body } .)
    {               reduce using rule 24 (exp -> IF exp { body } .)
    BINARY_OPERATOR reduce using rule 24 (exp -> IF exp { body } .)


state 89

    (25) exp -> TRY { body } CATCH . { body }

    {               shift and go to state 94


state 90

    (11) function -> COMMAND id ( parameter ) { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 95
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! }               [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    id                             shift and go to state 76
    exp                            shift and go to state 83
    variable                       shift and go to state 84
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 91

    (10) function -> FN id ( parameter ) { body } .

    FN              reduce using rule 10 (function -> FN id ( parameter ) { body } .)
    COMMAND         reduce using rule 10 (function -> FN id ( parameter ) { body } .)
    TOKEN           reduce using rule 10 (function -> FN id ( parameter ) { body } .)
    ID              reduce using rule 10 (function -> FN id ( parameter ) { body } .)
    $end            reduce using rule 10 (function -> FN id ( parameter ) { body } .)


state 92

    (27) term_map -> term : term , term_map .

    }               reduce using rule 27 (term_map -> term : term , term_map .)


state 93

    (23) exp -> IF exp { body } ELSE . { body }

    {               shift and go to state 96


state 94

    (25) exp -> TRY { body } CATCH { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . exp
    (20) body -> . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    body                           shift and go to state 97
    exp                            shift and go to state 74
    variable                       shift and go to state 75
    term                           shift and go to state 42
    id                             shift and go to state 76
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 95

    (11) function -> COMMAND id ( parameter ) { body } .

    FN              reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)
    COMMAND         reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)
    TOKEN           reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)
    ID              reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)
    $end            reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)


state 96

    (23) exp -> IF exp { body } ELSE { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . exp
    (20) body -> . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)
    }               reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    exp                            shift and go to state 74
    body                           shift and go to state 98
    variable                       shift and go to state 75
    term                           shift and go to state 42
    id                             shift and go to state 76
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 97

    (25) exp -> TRY { body } CATCH { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 99
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! }               [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    exp                            shift and go to state 83
    variable                       shift and go to state 84
    term                           shift and go to state 42
    id                             shift and go to state 76
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 98

    (23) exp -> IF exp { body } ELSE { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (21) exp -> . term binop exp
    (22) exp -> . term
    (23) exp -> . IF exp { body } ELSE { body }
    (24) exp -> . IF exp { body }
    (25) exp -> . TRY { body } CATCH { body }
    (26) variable -> . id = exp
    (31) term -> . unop term
    (32) term -> . number
    (33) term -> . boolean
    (34) term -> . string
    (35) term -> . function_call
    (36) term -> . id
    (37) term -> . list
    (38) term -> . dict
    (39) term -> . empty
    (51) id -> . ID
    (40) unop -> . SIGN
    (41) unop -> . UNITARY_OPERATOR
    (47) number -> . FLOAT
    (48) number -> . INTEGER
    (49) boolean -> . BOOLEAN
    (50) string -> . STRING
    (13) function_call -> . id ( term_list )
    (46) list -> . [ term_list ]
    (44) dict -> . { term_map }
    (45) dict -> . { empty }
    (52) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 100
    IF              shift and go to state 43
    TRY             shift and go to state 44
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 52 (empty -> .)

  ! SIGN            [ reduce using rule 52 (empty -> .) ]
  ! }               [ reduce using rule 52 (empty -> .) ]
  ! IF              [ reduce using rule 52 (empty -> .) ]
  ! TRY             [ reduce using rule 52 (empty -> .) ]
  ! ID              [ reduce using rule 52 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 52 (empty -> .) ]
  ! FLOAT           [ reduce using rule 52 (empty -> .) ]
  ! INTEGER         [ reduce using rule 52 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 52 (empty -> .) ]
  ! STRING          [ reduce using rule 52 (empty -> .) ]
  ! [               [ reduce using rule 52 (empty -> .) ]
  ! {               [ reduce using rule 52 (empty -> .) ]

    exp                            shift and go to state 83
    variable                       shift and go to state 84
    term                           shift and go to state 42
    id                             shift and go to state 76
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 99

    (25) exp -> TRY { body } CATCH { body } .

    FN              reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    COMMAND         reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    TOKEN           reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    ID              reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    $end            reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    }               reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    IF              reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    TRY             reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    SIGN            reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    UNITARY_OPERATOR reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    FLOAT           reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    INTEGER         reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    BOOLEAN         reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    STRING          reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    [               reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    {               reduce using rule 25 (exp -> TRY { body } CATCH { body } .)
    BINARY_OPERATOR reduce using rule 25 (exp -> TRY { body } CATCH { body } .)


state 100

    (23) exp -> IF exp { body } ELSE { body } .

    FN              reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    COMMAND         reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    TOKEN           reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    ID              reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    $end            reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    }               reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    IF              reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    TRY             reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    SIGN            reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    UNITARY_OPERATOR reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    FLOAT           reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    INTEGER         reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    BOOLEAN         reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    STRING          reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    [               reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    {               reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)
    BINARY_OPERATOR reduce using rule 23 (exp -> IF exp { body } ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SIGN in state 18 resolved as shift
WARNING: shift/reduce conflict for ID in state 18 resolved as shift
WARNING: shift/reduce conflict for IF in state 18 resolved as shift
WARNING: shift/reduce conflict for TRY in state 18 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 18 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 18 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 18 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 18 resolved as shift
WARNING: shift/reduce conflict for STRING in state 18 resolved as shift
WARNING: shift/reduce conflict for [ in state 18 resolved as shift
WARNING: shift/reduce conflict for { in state 18 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 25 resolved as shift
WARNING: shift/reduce conflict for ID in state 25 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 25 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 25 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 25 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 25 resolved as shift
WARNING: shift/reduce conflict for STRING in state 25 resolved as shift
WARNING: shift/reduce conflict for [ in state 25 resolved as shift
WARNING: shift/reduce conflict for { in state 25 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 42 resolved as shift
WARNING: shift/reduce conflict for BINARY_OPERATOR in state 42 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 43 resolved as shift
WARNING: shift/reduce conflict for { in state 43 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 57 resolved as shift
WARNING: shift/reduce conflict for ID in state 57 resolved as shift
WARNING: shift/reduce conflict for IF in state 57 resolved as shift
WARNING: shift/reduce conflict for TRY in state 57 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 57 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 57 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 57 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 57 resolved as shift
WARNING: shift/reduce conflict for STRING in state 57 resolved as shift
WARNING: shift/reduce conflict for [ in state 57 resolved as shift
WARNING: shift/reduce conflict for { in state 57 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 61 resolved as shift
WARNING: shift/reduce conflict for IF in state 61 resolved as shift
WARNING: shift/reduce conflict for TRY in state 61 resolved as shift
WARNING: shift/reduce conflict for ID in state 61 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 61 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 61 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 61 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 61 resolved as shift
WARNING: shift/reduce conflict for STRING in state 61 resolved as shift
WARNING: shift/reduce conflict for [ in state 61 resolved as shift
WARNING: shift/reduce conflict for { in state 61 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for TRY in state 72 resolved as shift
WARNING: shift/reduce conflict for ID in state 72 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 72 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 72 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 72 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 72 resolved as shift
WARNING: shift/reduce conflict for STRING in state 72 resolved as shift
WARNING: shift/reduce conflict for [ in state 72 resolved as shift
WARNING: shift/reduce conflict for { in state 72 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 73 resolved as shift
WARNING: shift/reduce conflict for } in state 73 resolved as shift
WARNING: shift/reduce conflict for IF in state 73 resolved as shift
WARNING: shift/reduce conflict for TRY in state 73 resolved as shift
WARNING: shift/reduce conflict for ID in state 73 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 73 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 73 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 73 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 73 resolved as shift
WARNING: shift/reduce conflict for STRING in state 73 resolved as shift
WARNING: shift/reduce conflict for [ in state 73 resolved as shift
WARNING: shift/reduce conflict for { in state 73 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 79 resolved as shift
WARNING: shift/reduce conflict for IF in state 79 resolved as shift
WARNING: shift/reduce conflict for TRY in state 79 resolved as shift
WARNING: shift/reduce conflict for ID in state 79 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 79 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 79 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 79 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 79 resolved as shift
WARNING: shift/reduce conflict for STRING in state 79 resolved as shift
WARNING: shift/reduce conflict for [ in state 79 resolved as shift
WARNING: shift/reduce conflict for { in state 79 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 81 resolved as shift
WARNING: shift/reduce conflict for } in state 81 resolved as shift
WARNING: shift/reduce conflict for IF in state 81 resolved as shift
WARNING: shift/reduce conflict for TRY in state 81 resolved as shift
WARNING: shift/reduce conflict for ID in state 81 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 81 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 81 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 81 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 81 resolved as shift
WARNING: shift/reduce conflict for STRING in state 81 resolved as shift
WARNING: shift/reduce conflict for [ in state 81 resolved as shift
WARNING: shift/reduce conflict for { in state 81 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 85 resolved as shift
WARNING: shift/reduce conflict for IF in state 85 resolved as shift
WARNING: shift/reduce conflict for TRY in state 85 resolved as shift
WARNING: shift/reduce conflict for ID in state 85 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 85 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 85 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 85 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 85 resolved as shift
WARNING: shift/reduce conflict for STRING in state 85 resolved as shift
WARNING: shift/reduce conflict for [ in state 85 resolved as shift
WARNING: shift/reduce conflict for { in state 85 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 86 resolved as shift
WARNING: shift/reduce conflict for } in state 86 resolved as shift
WARNING: shift/reduce conflict for IF in state 86 resolved as shift
WARNING: shift/reduce conflict for TRY in state 86 resolved as shift
WARNING: shift/reduce conflict for ID in state 86 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 86 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 86 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 86 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 86 resolved as shift
WARNING: shift/reduce conflict for STRING in state 86 resolved as shift
WARNING: shift/reduce conflict for [ in state 86 resolved as shift
WARNING: shift/reduce conflict for { in state 86 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 90 resolved as shift
WARNING: shift/reduce conflict for } in state 90 resolved as shift
WARNING: shift/reduce conflict for IF in state 90 resolved as shift
WARNING: shift/reduce conflict for TRY in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 90 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 90 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 90 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 90 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 90 resolved as shift
WARNING: shift/reduce conflict for STRING in state 90 resolved as shift
WARNING: shift/reduce conflict for [ in state 90 resolved as shift
WARNING: shift/reduce conflict for { in state 90 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 94 resolved as shift
WARNING: shift/reduce conflict for IF in state 94 resolved as shift
WARNING: shift/reduce conflict for TRY in state 94 resolved as shift
WARNING: shift/reduce conflict for ID in state 94 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 94 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 94 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 94 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 94 resolved as shift
WARNING: shift/reduce conflict for STRING in state 94 resolved as shift
WARNING: shift/reduce conflict for [ in state 94 resolved as shift
WARNING: shift/reduce conflict for { in state 94 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 96 resolved as shift
WARNING: shift/reduce conflict for IF in state 96 resolved as shift
WARNING: shift/reduce conflict for TRY in state 96 resolved as shift
WARNING: shift/reduce conflict for ID in state 96 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 96 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 96 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 96 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 96 resolved as shift
WARNING: shift/reduce conflict for STRING in state 96 resolved as shift
WARNING: shift/reduce conflict for [ in state 96 resolved as shift
WARNING: shift/reduce conflict for { in state 96 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 97 resolved as shift
WARNING: shift/reduce conflict for } in state 97 resolved as shift
WARNING: shift/reduce conflict for IF in state 97 resolved as shift
WARNING: shift/reduce conflict for TRY in state 97 resolved as shift
WARNING: shift/reduce conflict for ID in state 97 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 97 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 97 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 97 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 97 resolved as shift
WARNING: shift/reduce conflict for STRING in state 97 resolved as shift
WARNING: shift/reduce conflict for [ in state 97 resolved as shift
WARNING: shift/reduce conflict for { in state 97 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 98 resolved as shift
WARNING: shift/reduce conflict for } in state 98 resolved as shift
WARNING: shift/reduce conflict for IF in state 98 resolved as shift
WARNING: shift/reduce conflict for TRY in state 98 resolved as shift
WARNING: shift/reduce conflict for ID in state 98 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 98 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 98 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 98 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 98 resolved as shift
WARNING: shift/reduce conflict for STRING in state 98 resolved as shift
WARNING: shift/reduce conflict for [ in state 98 resolved as shift
WARNING: shift/reduce conflict for { in state 98 resolved as shift
