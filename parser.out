Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> run
Rule 1     run -> program
Rule 2     program -> program function
Rule 3     program -> program function_call
Rule 4     program -> program variable
Rule 5     program -> function
Rule 6     program -> function_call
Rule 7     program -> variable
Rule 8     function -> FN id ( parameter ) { body }
Rule 9     function -> COMMAND id ( parameter ) { body }
Rule 10    function -> HANDLER id ( parameter ) { body }
Rule 11    function_call -> id ( term_list )
Rule 12    parameter -> id , parameter
Rule 13    parameter -> id
Rule 14    parameter -> empty
Rule 15    body -> body exp
Rule 16    body -> body variable
Rule 17    body -> exp
Rule 18    body -> variable
Rule 19    exp -> term binop exp
Rule 20    exp -> term
Rule 21    exp -> IF exp { body } ELSE { body }
Rule 22    exp -> IF exp { body }
Rule 23    exp -> TRY { body } CATCH { body }
Rule 24    variable -> id = exp
Rule 25    term_map -> term : term , term_map
Rule 26    term_map -> term : term
Rule 27    term_list -> term_list , term
Rule 28    term_list -> term
Rule 29    term -> unop term
Rule 30    term -> number
Rule 31    term -> boolean
Rule 32    term -> string
Rule 33    term -> function_call
Rule 34    term -> id
Rule 35    term -> list
Rule 36    term -> dict
Rule 37    term -> empty
Rule 38    unop -> SIGN
Rule 39    unop -> UNITARY_OPERATOR
Rule 40    binop -> SIGN
Rule 41    binop -> BINARY_OPERATOR
Rule 42    dict -> { term_map }
Rule 43    dict -> { empty }
Rule 44    list -> [ term_list ]
Rule 45    number -> FLOAT
Rule 46    number -> INTEGER
Rule 47    boolean -> BOOLEAN
Rule 48    string -> STRING
Rule 49    id -> ID
Rule 50    empty -> <empty>

Terminals, with rules where they appear

(                    : 8 9 10 11
)                    : 8 9 10 11
,                    : 12 25 27
:                    : 25 26
=                    : 24
BINARY_OPERATOR      : 41
BOOLEAN              : 47
CATCH                : 23
COMMAND              : 9
ELSE                 : 21
FLOAT                : 45
FN                   : 8
HANDLER              : 10
ID                   : 49
IF                   : 21 22
INTEGER              : 46
SIGN                 : 38 40
STRING               : 48
TRY                  : 23
UNITARY_OPERATOR     : 39
[                    : 44
]                    : 44
error                : 
{                    : 8 9 10 21 21 22 23 23 42 43
}                    : 8 9 10 21 21 22 23 23 42 43

Nonterminals, with rules where they appear

binop                : 19
body                 : 8 9 10 15 16 21 21 22 23 23
boolean              : 31
dict                 : 36
empty                : 14 37 43
exp                  : 15 17 19 21 22 24
function             : 2 5
function_call        : 3 6 33
id                   : 8 9 10 11 12 13 24 34
list                 : 35
number               : 30
parameter            : 8 9 10 12
program              : 1 2 3 4
run                  : 0
string               : 32
term                 : 19 20 25 25 26 26 27 28 29
term_list            : 11 27 44
term_map             : 25 42
unop                 : 29
variable             : 4 7 16 18

Parsing method: LALR

state 0

    (0) S' -> . run
    (1) run -> . program
    (2) program -> . program function
    (3) program -> . program function_call
    (4) program -> . program variable
    (5) program -> . function
    (6) program -> . function_call
    (7) program -> . variable
    (8) function -> . FN id ( parameter ) { body }
    (9) function -> . COMMAND id ( parameter ) { body }
    (10) function -> . HANDLER id ( parameter ) { body }
    (11) function_call -> . id ( term_list )
    (24) variable -> . id = exp
    (49) id -> . ID

    FN              shift and go to state 6
    COMMAND         shift and go to state 8
    HANDLER         shift and go to state 9
    ID              shift and go to state 10

    run                            shift and go to state 1
    program                        shift and go to state 2
    function                       shift and go to state 3
    function_call                  shift and go to state 4
    variable                       shift and go to state 5
    id                             shift and go to state 7

state 1

    (0) S' -> run .



state 2

    (1) run -> program .
    (2) program -> program . function
    (3) program -> program . function_call
    (4) program -> program . variable
    (8) function -> . FN id ( parameter ) { body }
    (9) function -> . COMMAND id ( parameter ) { body }
    (10) function -> . HANDLER id ( parameter ) { body }
    (11) function_call -> . id ( term_list )
    (24) variable -> . id = exp
    (49) id -> . ID

    $end            reduce using rule 1 (run -> program .)
    FN              shift and go to state 6
    COMMAND         shift and go to state 8
    HANDLER         shift and go to state 9
    ID              shift and go to state 10

    function                       shift and go to state 11
    function_call                  shift and go to state 12
    variable                       shift and go to state 13
    id                             shift and go to state 7

state 3

    (5) program -> function .

    FN              reduce using rule 5 (program -> function .)
    COMMAND         reduce using rule 5 (program -> function .)
    HANDLER         reduce using rule 5 (program -> function .)
    ID              reduce using rule 5 (program -> function .)
    $end            reduce using rule 5 (program -> function .)


state 4

    (6) program -> function_call .

    FN              reduce using rule 6 (program -> function_call .)
    COMMAND         reduce using rule 6 (program -> function_call .)
    HANDLER         reduce using rule 6 (program -> function_call .)
    ID              reduce using rule 6 (program -> function_call .)
    $end            reduce using rule 6 (program -> function_call .)


state 5

    (7) program -> variable .

    FN              reduce using rule 7 (program -> variable .)
    COMMAND         reduce using rule 7 (program -> variable .)
    HANDLER         reduce using rule 7 (program -> variable .)
    ID              reduce using rule 7 (program -> variable .)
    $end            reduce using rule 7 (program -> variable .)


state 6

    (8) function -> FN . id ( parameter ) { body }
    (49) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 14

state 7

    (11) function_call -> id . ( term_list )
    (24) variable -> id . = exp

    (               shift and go to state 15
    =               shift and go to state 16


state 8

    (9) function -> COMMAND . id ( parameter ) { body }
    (49) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 17

state 9

    (10) function -> HANDLER . id ( parameter ) { body }
    (49) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 18

state 10

    (49) id -> ID .

    (               reduce using rule 49 (id -> ID .)
    =               reduce using rule 49 (id -> ID .)
    )               reduce using rule 49 (id -> ID .)
    ,               reduce using rule 49 (id -> ID .)
    SIGN            reduce using rule 49 (id -> ID .)
    BINARY_OPERATOR reduce using rule 49 (id -> ID .)
    FN              reduce using rule 49 (id -> ID .)
    COMMAND         reduce using rule 49 (id -> ID .)
    HANDLER         reduce using rule 49 (id -> ID .)
    ID              reduce using rule 49 (id -> ID .)
    $end            reduce using rule 49 (id -> ID .)
    }               reduce using rule 49 (id -> ID .)
    IF              reduce using rule 49 (id -> ID .)
    TRY             reduce using rule 49 (id -> ID .)
    UNITARY_OPERATOR reduce using rule 49 (id -> ID .)
    FLOAT           reduce using rule 49 (id -> ID .)
    INTEGER         reduce using rule 49 (id -> ID .)
    BOOLEAN         reduce using rule 49 (id -> ID .)
    STRING          reduce using rule 49 (id -> ID .)
    [               reduce using rule 49 (id -> ID .)
    {               reduce using rule 49 (id -> ID .)
    ]               reduce using rule 49 (id -> ID .)
    :               reduce using rule 49 (id -> ID .)


state 11

    (2) program -> program function .

    FN              reduce using rule 2 (program -> program function .)
    COMMAND         reduce using rule 2 (program -> program function .)
    HANDLER         reduce using rule 2 (program -> program function .)
    ID              reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 12

    (3) program -> program function_call .

    FN              reduce using rule 3 (program -> program function_call .)
    COMMAND         reduce using rule 3 (program -> program function_call .)
    HANDLER         reduce using rule 3 (program -> program function_call .)
    ID              reduce using rule 3 (program -> program function_call .)
    $end            reduce using rule 3 (program -> program function_call .)


state 13

    (4) program -> program variable .

    FN              reduce using rule 4 (program -> program variable .)
    COMMAND         reduce using rule 4 (program -> program variable .)
    HANDLER         reduce using rule 4 (program -> program variable .)
    ID              reduce using rule 4 (program -> program variable .)
    $end            reduce using rule 4 (program -> program variable .)


state 14

    (8) function -> FN id . ( parameter ) { body }

    (               shift and go to state 19


state 15

    (11) function_call -> id ( . term_list )
    (27) term_list -> . term_list , term
    (28) term_list -> . term
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    )               reduce using rule 50 (empty -> .)
    ,               reduce using rule 50 (empty -> .)

    id                             shift and go to state 20
    term_list                      shift and go to state 21
    term                           shift and go to state 22
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 16

    (24) variable -> id = . exp
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    FN              reduce using rule 50 (empty -> .)
    COMMAND         reduce using rule 50 (empty -> .)
    HANDLER         reduce using rule 50 (empty -> .)
    $end            reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    id                             shift and go to state 20
    exp                            shift and go to state 39
    term                           shift and go to state 40
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 17

    (9) function -> COMMAND id . ( parameter ) { body }

    (               shift and go to state 43


state 18

    (10) function -> HANDLER id . ( parameter ) { body }

    (               shift and go to state 44


state 19

    (8) function -> FN id ( . parameter ) { body }
    (12) parameter -> . id , parameter
    (13) parameter -> . id
    (14) parameter -> . empty
    (49) id -> . ID
    (50) empty -> .

    ID              shift and go to state 10
    )               reduce using rule 50 (empty -> .)

    id                             shift and go to state 45
    parameter                      shift and go to state 46
    empty                          shift and go to state 47

state 20

    (34) term -> id .
    (11) function_call -> id . ( term_list )

    )               reduce using rule 34 (term -> id .)
    ,               reduce using rule 34 (term -> id .)
    SIGN            reduce using rule 34 (term -> id .)
    BINARY_OPERATOR reduce using rule 34 (term -> id .)
    FN              reduce using rule 34 (term -> id .)
    COMMAND         reduce using rule 34 (term -> id .)
    HANDLER         reduce using rule 34 (term -> id .)
    ID              reduce using rule 34 (term -> id .)
    $end            reduce using rule 34 (term -> id .)
    }               reduce using rule 34 (term -> id .)
    IF              reduce using rule 34 (term -> id .)
    TRY             reduce using rule 34 (term -> id .)
    UNITARY_OPERATOR reduce using rule 34 (term -> id .)
    FLOAT           reduce using rule 34 (term -> id .)
    INTEGER         reduce using rule 34 (term -> id .)
    BOOLEAN         reduce using rule 34 (term -> id .)
    STRING          reduce using rule 34 (term -> id .)
    [               reduce using rule 34 (term -> id .)
    {               reduce using rule 34 (term -> id .)
    ]               reduce using rule 34 (term -> id .)
    :               reduce using rule 34 (term -> id .)
    (               shift and go to state 15


state 21

    (11) function_call -> id ( term_list . )
    (27) term_list -> term_list . , term

    )               shift and go to state 48
    ,               shift and go to state 49


state 22

    (28) term_list -> term .

    )               reduce using rule 28 (term_list -> term .)
    ,               reduce using rule 28 (term_list -> term .)
    ]               reduce using rule 28 (term_list -> term .)


state 23

    (29) term -> unop . term
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    )               reduce using rule 50 (empty -> .)
    ,               reduce using rule 50 (empty -> .)
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    FN              reduce using rule 50 (empty -> .)
    COMMAND         reduce using rule 50 (empty -> .)
    HANDLER         reduce using rule 50 (empty -> .)
    $end            reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)
    IF              reduce using rule 50 (empty -> .)
    TRY             reduce using rule 50 (empty -> .)
    ]               reduce using rule 50 (empty -> .)
    :               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    unop                           shift and go to state 23
    term                           shift and go to state 50
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    id                             shift and go to state 20
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 24

    (30) term -> number .

    )               reduce using rule 30 (term -> number .)
    ,               reduce using rule 30 (term -> number .)
    SIGN            reduce using rule 30 (term -> number .)
    BINARY_OPERATOR reduce using rule 30 (term -> number .)
    FN              reduce using rule 30 (term -> number .)
    COMMAND         reduce using rule 30 (term -> number .)
    HANDLER         reduce using rule 30 (term -> number .)
    ID              reduce using rule 30 (term -> number .)
    $end            reduce using rule 30 (term -> number .)
    }               reduce using rule 30 (term -> number .)
    IF              reduce using rule 30 (term -> number .)
    TRY             reduce using rule 30 (term -> number .)
    UNITARY_OPERATOR reduce using rule 30 (term -> number .)
    FLOAT           reduce using rule 30 (term -> number .)
    INTEGER         reduce using rule 30 (term -> number .)
    BOOLEAN         reduce using rule 30 (term -> number .)
    STRING          reduce using rule 30 (term -> number .)
    [               reduce using rule 30 (term -> number .)
    {               reduce using rule 30 (term -> number .)
    ]               reduce using rule 30 (term -> number .)
    :               reduce using rule 30 (term -> number .)


state 25

    (31) term -> boolean .

    )               reduce using rule 31 (term -> boolean .)
    ,               reduce using rule 31 (term -> boolean .)
    SIGN            reduce using rule 31 (term -> boolean .)
    BINARY_OPERATOR reduce using rule 31 (term -> boolean .)
    FN              reduce using rule 31 (term -> boolean .)
    COMMAND         reduce using rule 31 (term -> boolean .)
    HANDLER         reduce using rule 31 (term -> boolean .)
    ID              reduce using rule 31 (term -> boolean .)
    $end            reduce using rule 31 (term -> boolean .)
    }               reduce using rule 31 (term -> boolean .)
    IF              reduce using rule 31 (term -> boolean .)
    TRY             reduce using rule 31 (term -> boolean .)
    UNITARY_OPERATOR reduce using rule 31 (term -> boolean .)
    FLOAT           reduce using rule 31 (term -> boolean .)
    INTEGER         reduce using rule 31 (term -> boolean .)
    BOOLEAN         reduce using rule 31 (term -> boolean .)
    STRING          reduce using rule 31 (term -> boolean .)
    [               reduce using rule 31 (term -> boolean .)
    {               reduce using rule 31 (term -> boolean .)
    ]               reduce using rule 31 (term -> boolean .)
    :               reduce using rule 31 (term -> boolean .)


state 26

    (32) term -> string .

    )               reduce using rule 32 (term -> string .)
    ,               reduce using rule 32 (term -> string .)
    SIGN            reduce using rule 32 (term -> string .)
    BINARY_OPERATOR reduce using rule 32 (term -> string .)
    FN              reduce using rule 32 (term -> string .)
    COMMAND         reduce using rule 32 (term -> string .)
    HANDLER         reduce using rule 32 (term -> string .)
    ID              reduce using rule 32 (term -> string .)
    $end            reduce using rule 32 (term -> string .)
    }               reduce using rule 32 (term -> string .)
    IF              reduce using rule 32 (term -> string .)
    TRY             reduce using rule 32 (term -> string .)
    UNITARY_OPERATOR reduce using rule 32 (term -> string .)
    FLOAT           reduce using rule 32 (term -> string .)
    INTEGER         reduce using rule 32 (term -> string .)
    BOOLEAN         reduce using rule 32 (term -> string .)
    STRING          reduce using rule 32 (term -> string .)
    [               reduce using rule 32 (term -> string .)
    {               reduce using rule 32 (term -> string .)
    ]               reduce using rule 32 (term -> string .)
    :               reduce using rule 32 (term -> string .)


state 27

    (33) term -> function_call .

    )               reduce using rule 33 (term -> function_call .)
    ,               reduce using rule 33 (term -> function_call .)
    SIGN            reduce using rule 33 (term -> function_call .)
    BINARY_OPERATOR reduce using rule 33 (term -> function_call .)
    FN              reduce using rule 33 (term -> function_call .)
    COMMAND         reduce using rule 33 (term -> function_call .)
    HANDLER         reduce using rule 33 (term -> function_call .)
    ID              reduce using rule 33 (term -> function_call .)
    $end            reduce using rule 33 (term -> function_call .)
    }               reduce using rule 33 (term -> function_call .)
    IF              reduce using rule 33 (term -> function_call .)
    TRY             reduce using rule 33 (term -> function_call .)
    UNITARY_OPERATOR reduce using rule 33 (term -> function_call .)
    FLOAT           reduce using rule 33 (term -> function_call .)
    INTEGER         reduce using rule 33 (term -> function_call .)
    BOOLEAN         reduce using rule 33 (term -> function_call .)
    STRING          reduce using rule 33 (term -> function_call .)
    [               reduce using rule 33 (term -> function_call .)
    {               reduce using rule 33 (term -> function_call .)
    ]               reduce using rule 33 (term -> function_call .)
    :               reduce using rule 33 (term -> function_call .)


state 28

    (35) term -> list .

    )               reduce using rule 35 (term -> list .)
    ,               reduce using rule 35 (term -> list .)
    SIGN            reduce using rule 35 (term -> list .)
    BINARY_OPERATOR reduce using rule 35 (term -> list .)
    FN              reduce using rule 35 (term -> list .)
    COMMAND         reduce using rule 35 (term -> list .)
    HANDLER         reduce using rule 35 (term -> list .)
    ID              reduce using rule 35 (term -> list .)
    $end            reduce using rule 35 (term -> list .)
    }               reduce using rule 35 (term -> list .)
    IF              reduce using rule 35 (term -> list .)
    TRY             reduce using rule 35 (term -> list .)
    UNITARY_OPERATOR reduce using rule 35 (term -> list .)
    FLOAT           reduce using rule 35 (term -> list .)
    INTEGER         reduce using rule 35 (term -> list .)
    BOOLEAN         reduce using rule 35 (term -> list .)
    STRING          reduce using rule 35 (term -> list .)
    [               reduce using rule 35 (term -> list .)
    {               reduce using rule 35 (term -> list .)
    ]               reduce using rule 35 (term -> list .)
    :               reduce using rule 35 (term -> list .)


state 29

    (36) term -> dict .

    )               reduce using rule 36 (term -> dict .)
    ,               reduce using rule 36 (term -> dict .)
    SIGN            reduce using rule 36 (term -> dict .)
    BINARY_OPERATOR reduce using rule 36 (term -> dict .)
    FN              reduce using rule 36 (term -> dict .)
    COMMAND         reduce using rule 36 (term -> dict .)
    HANDLER         reduce using rule 36 (term -> dict .)
    ID              reduce using rule 36 (term -> dict .)
    $end            reduce using rule 36 (term -> dict .)
    }               reduce using rule 36 (term -> dict .)
    IF              reduce using rule 36 (term -> dict .)
    TRY             reduce using rule 36 (term -> dict .)
    UNITARY_OPERATOR reduce using rule 36 (term -> dict .)
    FLOAT           reduce using rule 36 (term -> dict .)
    INTEGER         reduce using rule 36 (term -> dict .)
    BOOLEAN         reduce using rule 36 (term -> dict .)
    STRING          reduce using rule 36 (term -> dict .)
    [               reduce using rule 36 (term -> dict .)
    {               reduce using rule 36 (term -> dict .)
    ]               reduce using rule 36 (term -> dict .)
    :               reduce using rule 36 (term -> dict .)


state 30

    (37) term -> empty .

    )               reduce using rule 37 (term -> empty .)
    ,               reduce using rule 37 (term -> empty .)
    SIGN            reduce using rule 37 (term -> empty .)
    BINARY_OPERATOR reduce using rule 37 (term -> empty .)
    FN              reduce using rule 37 (term -> empty .)
    COMMAND         reduce using rule 37 (term -> empty .)
    HANDLER         reduce using rule 37 (term -> empty .)
    ID              reduce using rule 37 (term -> empty .)
    $end            reduce using rule 37 (term -> empty .)
    }               reduce using rule 37 (term -> empty .)
    IF              reduce using rule 37 (term -> empty .)
    TRY             reduce using rule 37 (term -> empty .)
    UNITARY_OPERATOR reduce using rule 37 (term -> empty .)
    FLOAT           reduce using rule 37 (term -> empty .)
    INTEGER         reduce using rule 37 (term -> empty .)
    BOOLEAN         reduce using rule 37 (term -> empty .)
    STRING          reduce using rule 37 (term -> empty .)
    [               reduce using rule 37 (term -> empty .)
    {               reduce using rule 37 (term -> empty .)
    ]               reduce using rule 37 (term -> empty .)
    :               reduce using rule 37 (term -> empty .)


state 31

    (38) unop -> SIGN .

    SIGN            reduce using rule 38 (unop -> SIGN .)
    UNITARY_OPERATOR reduce using rule 38 (unop -> SIGN .)
    FLOAT           reduce using rule 38 (unop -> SIGN .)
    INTEGER         reduce using rule 38 (unop -> SIGN .)
    BOOLEAN         reduce using rule 38 (unop -> SIGN .)
    STRING          reduce using rule 38 (unop -> SIGN .)
    ID              reduce using rule 38 (unop -> SIGN .)
    [               reduce using rule 38 (unop -> SIGN .)
    {               reduce using rule 38 (unop -> SIGN .)
    )               reduce using rule 38 (unop -> SIGN .)
    ,               reduce using rule 38 (unop -> SIGN .)
    BINARY_OPERATOR reduce using rule 38 (unop -> SIGN .)
    FN              reduce using rule 38 (unop -> SIGN .)
    COMMAND         reduce using rule 38 (unop -> SIGN .)
    HANDLER         reduce using rule 38 (unop -> SIGN .)
    $end            reduce using rule 38 (unop -> SIGN .)
    }               reduce using rule 38 (unop -> SIGN .)
    IF              reduce using rule 38 (unop -> SIGN .)
    TRY             reduce using rule 38 (unop -> SIGN .)
    ]               reduce using rule 38 (unop -> SIGN .)
    :               reduce using rule 38 (unop -> SIGN .)


state 32

    (39) unop -> UNITARY_OPERATOR .

    SIGN            reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    UNITARY_OPERATOR reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    FLOAT           reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    INTEGER         reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    BOOLEAN         reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    STRING          reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    ID              reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    [               reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    {               reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    )               reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    ,               reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    BINARY_OPERATOR reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    FN              reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    COMMAND         reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    HANDLER         reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    $end            reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    }               reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    IF              reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    TRY             reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    ]               reduce using rule 39 (unop -> UNITARY_OPERATOR .)
    :               reduce using rule 39 (unop -> UNITARY_OPERATOR .)


state 33

    (45) number -> FLOAT .

    )               reduce using rule 45 (number -> FLOAT .)
    ,               reduce using rule 45 (number -> FLOAT .)
    SIGN            reduce using rule 45 (number -> FLOAT .)
    BINARY_OPERATOR reduce using rule 45 (number -> FLOAT .)
    FN              reduce using rule 45 (number -> FLOAT .)
    COMMAND         reduce using rule 45 (number -> FLOAT .)
    HANDLER         reduce using rule 45 (number -> FLOAT .)
    ID              reduce using rule 45 (number -> FLOAT .)
    $end            reduce using rule 45 (number -> FLOAT .)
    }               reduce using rule 45 (number -> FLOAT .)
    IF              reduce using rule 45 (number -> FLOAT .)
    TRY             reduce using rule 45 (number -> FLOAT .)
    UNITARY_OPERATOR reduce using rule 45 (number -> FLOAT .)
    FLOAT           reduce using rule 45 (number -> FLOAT .)
    INTEGER         reduce using rule 45 (number -> FLOAT .)
    BOOLEAN         reduce using rule 45 (number -> FLOAT .)
    STRING          reduce using rule 45 (number -> FLOAT .)
    [               reduce using rule 45 (number -> FLOAT .)
    {               reduce using rule 45 (number -> FLOAT .)
    ]               reduce using rule 45 (number -> FLOAT .)
    :               reduce using rule 45 (number -> FLOAT .)


state 34

    (46) number -> INTEGER .

    )               reduce using rule 46 (number -> INTEGER .)
    ,               reduce using rule 46 (number -> INTEGER .)
    SIGN            reduce using rule 46 (number -> INTEGER .)
    BINARY_OPERATOR reduce using rule 46 (number -> INTEGER .)
    FN              reduce using rule 46 (number -> INTEGER .)
    COMMAND         reduce using rule 46 (number -> INTEGER .)
    HANDLER         reduce using rule 46 (number -> INTEGER .)
    ID              reduce using rule 46 (number -> INTEGER .)
    $end            reduce using rule 46 (number -> INTEGER .)
    }               reduce using rule 46 (number -> INTEGER .)
    IF              reduce using rule 46 (number -> INTEGER .)
    TRY             reduce using rule 46 (number -> INTEGER .)
    UNITARY_OPERATOR reduce using rule 46 (number -> INTEGER .)
    FLOAT           reduce using rule 46 (number -> INTEGER .)
    INTEGER         reduce using rule 46 (number -> INTEGER .)
    BOOLEAN         reduce using rule 46 (number -> INTEGER .)
    STRING          reduce using rule 46 (number -> INTEGER .)
    [               reduce using rule 46 (number -> INTEGER .)
    {               reduce using rule 46 (number -> INTEGER .)
    ]               reduce using rule 46 (number -> INTEGER .)
    :               reduce using rule 46 (number -> INTEGER .)


state 35

    (47) boolean -> BOOLEAN .

    )               reduce using rule 47 (boolean -> BOOLEAN .)
    ,               reduce using rule 47 (boolean -> BOOLEAN .)
    SIGN            reduce using rule 47 (boolean -> BOOLEAN .)
    BINARY_OPERATOR reduce using rule 47 (boolean -> BOOLEAN .)
    FN              reduce using rule 47 (boolean -> BOOLEAN .)
    COMMAND         reduce using rule 47 (boolean -> BOOLEAN .)
    HANDLER         reduce using rule 47 (boolean -> BOOLEAN .)
    ID              reduce using rule 47 (boolean -> BOOLEAN .)
    $end            reduce using rule 47 (boolean -> BOOLEAN .)
    }               reduce using rule 47 (boolean -> BOOLEAN .)
    IF              reduce using rule 47 (boolean -> BOOLEAN .)
    TRY             reduce using rule 47 (boolean -> BOOLEAN .)
    UNITARY_OPERATOR reduce using rule 47 (boolean -> BOOLEAN .)
    FLOAT           reduce using rule 47 (boolean -> BOOLEAN .)
    INTEGER         reduce using rule 47 (boolean -> BOOLEAN .)
    BOOLEAN         reduce using rule 47 (boolean -> BOOLEAN .)
    STRING          reduce using rule 47 (boolean -> BOOLEAN .)
    [               reduce using rule 47 (boolean -> BOOLEAN .)
    {               reduce using rule 47 (boolean -> BOOLEAN .)
    ]               reduce using rule 47 (boolean -> BOOLEAN .)
    :               reduce using rule 47 (boolean -> BOOLEAN .)


state 36

    (48) string -> STRING .

    )               reduce using rule 48 (string -> STRING .)
    ,               reduce using rule 48 (string -> STRING .)
    SIGN            reduce using rule 48 (string -> STRING .)
    BINARY_OPERATOR reduce using rule 48 (string -> STRING .)
    FN              reduce using rule 48 (string -> STRING .)
    COMMAND         reduce using rule 48 (string -> STRING .)
    HANDLER         reduce using rule 48 (string -> STRING .)
    ID              reduce using rule 48 (string -> STRING .)
    $end            reduce using rule 48 (string -> STRING .)
    }               reduce using rule 48 (string -> STRING .)
    IF              reduce using rule 48 (string -> STRING .)
    TRY             reduce using rule 48 (string -> STRING .)
    UNITARY_OPERATOR reduce using rule 48 (string -> STRING .)
    FLOAT           reduce using rule 48 (string -> STRING .)
    INTEGER         reduce using rule 48 (string -> STRING .)
    BOOLEAN         reduce using rule 48 (string -> STRING .)
    STRING          reduce using rule 48 (string -> STRING .)
    [               reduce using rule 48 (string -> STRING .)
    {               reduce using rule 48 (string -> STRING .)
    ]               reduce using rule 48 (string -> STRING .)
    :               reduce using rule 48 (string -> STRING .)


state 37

    (44) list -> [ . term_list ]
    (27) term_list -> . term_list , term
    (28) term_list -> . term
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    ]               reduce using rule 50 (empty -> .)
    ,               reduce using rule 50 (empty -> .)

    term_list                      shift and go to state 51
    term                           shift and go to state 22
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    id                             shift and go to state 20
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 38

    (42) dict -> { . term_map }
    (43) dict -> { . empty }
    (25) term_map -> . term : term , term_map
    (26) term_map -> . term : term
    (50) empty -> .
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }

    }               reduce using rule 50 (empty -> .)
    :               reduce using rule 50 (empty -> .)
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38

    term_map                       shift and go to state 52
    empty                          shift and go to state 53
    term                           shift and go to state 54
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    id                             shift and go to state 20
    list                           shift and go to state 28
    dict                           shift and go to state 29

state 39

    (24) variable -> id = exp .

    FN              reduce using rule 24 (variable -> id = exp .)
    COMMAND         reduce using rule 24 (variable -> id = exp .)
    HANDLER         reduce using rule 24 (variable -> id = exp .)
    ID              reduce using rule 24 (variable -> id = exp .)
    $end            reduce using rule 24 (variable -> id = exp .)
    }               reduce using rule 24 (variable -> id = exp .)
    IF              reduce using rule 24 (variable -> id = exp .)
    TRY             reduce using rule 24 (variable -> id = exp .)
    SIGN            reduce using rule 24 (variable -> id = exp .)
    UNITARY_OPERATOR reduce using rule 24 (variable -> id = exp .)
    FLOAT           reduce using rule 24 (variable -> id = exp .)
    INTEGER         reduce using rule 24 (variable -> id = exp .)
    BOOLEAN         reduce using rule 24 (variable -> id = exp .)
    STRING          reduce using rule 24 (variable -> id = exp .)
    [               reduce using rule 24 (variable -> id = exp .)
    {               reduce using rule 24 (variable -> id = exp .)
    BINARY_OPERATOR reduce using rule 24 (variable -> id = exp .)


state 40

    (19) exp -> term . binop exp
    (20) exp -> term .
    (40) binop -> . SIGN
    (41) binop -> . BINARY_OPERATOR

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for BINARY_OPERATOR resolved as shift
    FN              reduce using rule 20 (exp -> term .)
    COMMAND         reduce using rule 20 (exp -> term .)
    HANDLER         reduce using rule 20 (exp -> term .)
    ID              reduce using rule 20 (exp -> term .)
    $end            reduce using rule 20 (exp -> term .)
    }               reduce using rule 20 (exp -> term .)
    IF              reduce using rule 20 (exp -> term .)
    TRY             reduce using rule 20 (exp -> term .)
    UNITARY_OPERATOR reduce using rule 20 (exp -> term .)
    FLOAT           reduce using rule 20 (exp -> term .)
    INTEGER         reduce using rule 20 (exp -> term .)
    BOOLEAN         reduce using rule 20 (exp -> term .)
    STRING          reduce using rule 20 (exp -> term .)
    [               reduce using rule 20 (exp -> term .)
    {               reduce using rule 20 (exp -> term .)
    SIGN            shift and go to state 56
    BINARY_OPERATOR shift and go to state 57

  ! SIGN            [ reduce using rule 20 (exp -> term .) ]
  ! BINARY_OPERATOR [ reduce using rule 20 (exp -> term .) ]

    binop                          shift and go to state 55

state 41

    (21) exp -> IF . exp { body } ELSE { body }
    (22) exp -> IF . exp { body }
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    exp                            shift and go to state 58
    term                           shift and go to state 40
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    id                             shift and go to state 20
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 42

    (23) exp -> TRY . { body } CATCH { body }

    {               shift and go to state 59


state 43

    (9) function -> COMMAND id ( . parameter ) { body }
    (12) parameter -> . id , parameter
    (13) parameter -> . id
    (14) parameter -> . empty
    (49) id -> . ID
    (50) empty -> .

    ID              shift and go to state 10
    )               reduce using rule 50 (empty -> .)

    id                             shift and go to state 45
    parameter                      shift and go to state 60
    empty                          shift and go to state 47

state 44

    (10) function -> HANDLER id ( . parameter ) { body }
    (12) parameter -> . id , parameter
    (13) parameter -> . id
    (14) parameter -> . empty
    (49) id -> . ID
    (50) empty -> .

    ID              shift and go to state 10
    )               reduce using rule 50 (empty -> .)

    id                             shift and go to state 45
    parameter                      shift and go to state 61
    empty                          shift and go to state 47

state 45

    (12) parameter -> id . , parameter
    (13) parameter -> id .

    ,               shift and go to state 62
    )               reduce using rule 13 (parameter -> id .)


state 46

    (8) function -> FN id ( parameter . ) { body }

    )               shift and go to state 63


state 47

    (14) parameter -> empty .

    )               reduce using rule 14 (parameter -> empty .)


state 48

    (11) function_call -> id ( term_list ) .

    FN              reduce using rule 11 (function_call -> id ( term_list ) .)
    COMMAND         reduce using rule 11 (function_call -> id ( term_list ) .)
    HANDLER         reduce using rule 11 (function_call -> id ( term_list ) .)
    ID              reduce using rule 11 (function_call -> id ( term_list ) .)
    $end            reduce using rule 11 (function_call -> id ( term_list ) .)
    )               reduce using rule 11 (function_call -> id ( term_list ) .)
    ,               reduce using rule 11 (function_call -> id ( term_list ) .)
    SIGN            reduce using rule 11 (function_call -> id ( term_list ) .)
    BINARY_OPERATOR reduce using rule 11 (function_call -> id ( term_list ) .)
    }               reduce using rule 11 (function_call -> id ( term_list ) .)
    IF              reduce using rule 11 (function_call -> id ( term_list ) .)
    TRY             reduce using rule 11 (function_call -> id ( term_list ) .)
    UNITARY_OPERATOR reduce using rule 11 (function_call -> id ( term_list ) .)
    FLOAT           reduce using rule 11 (function_call -> id ( term_list ) .)
    INTEGER         reduce using rule 11 (function_call -> id ( term_list ) .)
    BOOLEAN         reduce using rule 11 (function_call -> id ( term_list ) .)
    STRING          reduce using rule 11 (function_call -> id ( term_list ) .)
    [               reduce using rule 11 (function_call -> id ( term_list ) .)
    {               reduce using rule 11 (function_call -> id ( term_list ) .)
    ]               reduce using rule 11 (function_call -> id ( term_list ) .)
    :               reduce using rule 11 (function_call -> id ( term_list ) .)


state 49

    (27) term_list -> term_list , . term
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    )               reduce using rule 50 (empty -> .)
    ,               reduce using rule 50 (empty -> .)
    ]               reduce using rule 50 (empty -> .)

    term                           shift and go to state 64
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    id                             shift and go to state 20
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 50

    (29) term -> unop term .

    )               reduce using rule 29 (term -> unop term .)
    ,               reduce using rule 29 (term -> unop term .)
    SIGN            reduce using rule 29 (term -> unop term .)
    BINARY_OPERATOR reduce using rule 29 (term -> unop term .)
    FN              reduce using rule 29 (term -> unop term .)
    COMMAND         reduce using rule 29 (term -> unop term .)
    HANDLER         reduce using rule 29 (term -> unop term .)
    ID              reduce using rule 29 (term -> unop term .)
    $end            reduce using rule 29 (term -> unop term .)
    }               reduce using rule 29 (term -> unop term .)
    IF              reduce using rule 29 (term -> unop term .)
    TRY             reduce using rule 29 (term -> unop term .)
    UNITARY_OPERATOR reduce using rule 29 (term -> unop term .)
    FLOAT           reduce using rule 29 (term -> unop term .)
    INTEGER         reduce using rule 29 (term -> unop term .)
    BOOLEAN         reduce using rule 29 (term -> unop term .)
    STRING          reduce using rule 29 (term -> unop term .)
    [               reduce using rule 29 (term -> unop term .)
    {               reduce using rule 29 (term -> unop term .)
    ]               reduce using rule 29 (term -> unop term .)
    :               reduce using rule 29 (term -> unop term .)


state 51

    (44) list -> [ term_list . ]
    (27) term_list -> term_list . , term

    ]               shift and go to state 65
    ,               shift and go to state 49


state 52

    (42) dict -> { term_map . }

    }               shift and go to state 66


state 53

    (43) dict -> { empty . }
    (37) term -> empty .

    }               shift and go to state 67
    :               reduce using rule 37 (term -> empty .)


state 54

    (25) term_map -> term . : term , term_map
    (26) term_map -> term . : term

    :               shift and go to state 68


state 55

    (19) exp -> term binop . exp
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    FN              reduce using rule 50 (empty -> .)
    COMMAND         reduce using rule 50 (empty -> .)
    HANDLER         reduce using rule 50 (empty -> .)
    $end            reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    term                           shift and go to state 40
    exp                            shift and go to state 69
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    id                             shift and go to state 20
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 56

    (40) binop -> SIGN .

    IF              reduce using rule 40 (binop -> SIGN .)
    TRY             reduce using rule 40 (binop -> SIGN .)
    SIGN            reduce using rule 40 (binop -> SIGN .)
    UNITARY_OPERATOR reduce using rule 40 (binop -> SIGN .)
    FLOAT           reduce using rule 40 (binop -> SIGN .)
    INTEGER         reduce using rule 40 (binop -> SIGN .)
    BOOLEAN         reduce using rule 40 (binop -> SIGN .)
    STRING          reduce using rule 40 (binop -> SIGN .)
    ID              reduce using rule 40 (binop -> SIGN .)
    [               reduce using rule 40 (binop -> SIGN .)
    {               reduce using rule 40 (binop -> SIGN .)
    BINARY_OPERATOR reduce using rule 40 (binop -> SIGN .)
    FN              reduce using rule 40 (binop -> SIGN .)
    COMMAND         reduce using rule 40 (binop -> SIGN .)
    HANDLER         reduce using rule 40 (binop -> SIGN .)
    $end            reduce using rule 40 (binop -> SIGN .)
    }               reduce using rule 40 (binop -> SIGN .)


state 57

    (41) binop -> BINARY_OPERATOR .

    IF              reduce using rule 41 (binop -> BINARY_OPERATOR .)
    TRY             reduce using rule 41 (binop -> BINARY_OPERATOR .)
    SIGN            reduce using rule 41 (binop -> BINARY_OPERATOR .)
    UNITARY_OPERATOR reduce using rule 41 (binop -> BINARY_OPERATOR .)
    FLOAT           reduce using rule 41 (binop -> BINARY_OPERATOR .)
    INTEGER         reduce using rule 41 (binop -> BINARY_OPERATOR .)
    BOOLEAN         reduce using rule 41 (binop -> BINARY_OPERATOR .)
    STRING          reduce using rule 41 (binop -> BINARY_OPERATOR .)
    ID              reduce using rule 41 (binop -> BINARY_OPERATOR .)
    [               reduce using rule 41 (binop -> BINARY_OPERATOR .)
    {               reduce using rule 41 (binop -> BINARY_OPERATOR .)
    BINARY_OPERATOR reduce using rule 41 (binop -> BINARY_OPERATOR .)
    FN              reduce using rule 41 (binop -> BINARY_OPERATOR .)
    COMMAND         reduce using rule 41 (binop -> BINARY_OPERATOR .)
    HANDLER         reduce using rule 41 (binop -> BINARY_OPERATOR .)
    $end            reduce using rule 41 (binop -> BINARY_OPERATOR .)
    }               reduce using rule 41 (binop -> BINARY_OPERATOR .)


state 58

    (21) exp -> IF exp . { body } ELSE { body }
    (22) exp -> IF exp . { body }

    {               shift and go to state 70


state 59

    (23) exp -> TRY { . body } CATCH { body }
    (15) body -> . body exp
    (16) body -> . body variable
    (17) body -> . exp
    (18) body -> . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    body                           shift and go to state 71
    exp                            shift and go to state 72
    variable                       shift and go to state 73
    term                           shift and go to state 40
    id                             shift and go to state 74
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 60

    (9) function -> COMMAND id ( parameter . ) { body }

    )               shift and go to state 75


state 61

    (10) function -> HANDLER id ( parameter . ) { body }

    )               shift and go to state 76


state 62

    (12) parameter -> id , . parameter
    (12) parameter -> . id , parameter
    (13) parameter -> . id
    (14) parameter -> . empty
    (49) id -> . ID
    (50) empty -> .

    ID              shift and go to state 10
    )               reduce using rule 50 (empty -> .)

    id                             shift and go to state 45
    parameter                      shift and go to state 77
    empty                          shift and go to state 47

state 63

    (8) function -> FN id ( parameter ) . { body }

    {               shift and go to state 78


state 64

    (27) term_list -> term_list , term .

    )               reduce using rule 27 (term_list -> term_list , term .)
    ,               reduce using rule 27 (term_list -> term_list , term .)
    ]               reduce using rule 27 (term_list -> term_list , term .)


state 65

    (44) list -> [ term_list ] .

    )               reduce using rule 44 (list -> [ term_list ] .)
    ,               reduce using rule 44 (list -> [ term_list ] .)
    SIGN            reduce using rule 44 (list -> [ term_list ] .)
    BINARY_OPERATOR reduce using rule 44 (list -> [ term_list ] .)
    FN              reduce using rule 44 (list -> [ term_list ] .)
    COMMAND         reduce using rule 44 (list -> [ term_list ] .)
    HANDLER         reduce using rule 44 (list -> [ term_list ] .)
    ID              reduce using rule 44 (list -> [ term_list ] .)
    $end            reduce using rule 44 (list -> [ term_list ] .)
    }               reduce using rule 44 (list -> [ term_list ] .)
    IF              reduce using rule 44 (list -> [ term_list ] .)
    TRY             reduce using rule 44 (list -> [ term_list ] .)
    UNITARY_OPERATOR reduce using rule 44 (list -> [ term_list ] .)
    FLOAT           reduce using rule 44 (list -> [ term_list ] .)
    INTEGER         reduce using rule 44 (list -> [ term_list ] .)
    BOOLEAN         reduce using rule 44 (list -> [ term_list ] .)
    STRING          reduce using rule 44 (list -> [ term_list ] .)
    [               reduce using rule 44 (list -> [ term_list ] .)
    {               reduce using rule 44 (list -> [ term_list ] .)
    ]               reduce using rule 44 (list -> [ term_list ] .)
    :               reduce using rule 44 (list -> [ term_list ] .)


state 66

    (42) dict -> { term_map } .

    )               reduce using rule 42 (dict -> { term_map } .)
    ,               reduce using rule 42 (dict -> { term_map } .)
    SIGN            reduce using rule 42 (dict -> { term_map } .)
    BINARY_OPERATOR reduce using rule 42 (dict -> { term_map } .)
    FN              reduce using rule 42 (dict -> { term_map } .)
    COMMAND         reduce using rule 42 (dict -> { term_map } .)
    HANDLER         reduce using rule 42 (dict -> { term_map } .)
    ID              reduce using rule 42 (dict -> { term_map } .)
    $end            reduce using rule 42 (dict -> { term_map } .)
    }               reduce using rule 42 (dict -> { term_map } .)
    IF              reduce using rule 42 (dict -> { term_map } .)
    TRY             reduce using rule 42 (dict -> { term_map } .)
    UNITARY_OPERATOR reduce using rule 42 (dict -> { term_map } .)
    FLOAT           reduce using rule 42 (dict -> { term_map } .)
    INTEGER         reduce using rule 42 (dict -> { term_map } .)
    BOOLEAN         reduce using rule 42 (dict -> { term_map } .)
    STRING          reduce using rule 42 (dict -> { term_map } .)
    [               reduce using rule 42 (dict -> { term_map } .)
    {               reduce using rule 42 (dict -> { term_map } .)
    ]               reduce using rule 42 (dict -> { term_map } .)
    :               reduce using rule 42 (dict -> { term_map } .)


state 67

    (43) dict -> { empty } .

    )               reduce using rule 43 (dict -> { empty } .)
    ,               reduce using rule 43 (dict -> { empty } .)
    SIGN            reduce using rule 43 (dict -> { empty } .)
    BINARY_OPERATOR reduce using rule 43 (dict -> { empty } .)
    FN              reduce using rule 43 (dict -> { empty } .)
    COMMAND         reduce using rule 43 (dict -> { empty } .)
    HANDLER         reduce using rule 43 (dict -> { empty } .)
    ID              reduce using rule 43 (dict -> { empty } .)
    $end            reduce using rule 43 (dict -> { empty } .)
    }               reduce using rule 43 (dict -> { empty } .)
    IF              reduce using rule 43 (dict -> { empty } .)
    TRY             reduce using rule 43 (dict -> { empty } .)
    UNITARY_OPERATOR reduce using rule 43 (dict -> { empty } .)
    FLOAT           reduce using rule 43 (dict -> { empty } .)
    INTEGER         reduce using rule 43 (dict -> { empty } .)
    BOOLEAN         reduce using rule 43 (dict -> { empty } .)
    STRING          reduce using rule 43 (dict -> { empty } .)
    [               reduce using rule 43 (dict -> { empty } .)
    {               reduce using rule 43 (dict -> { empty } .)
    ]               reduce using rule 43 (dict -> { empty } .)
    :               reduce using rule 43 (dict -> { empty } .)


state 68

    (25) term_map -> term : . term , term_map
    (26) term_map -> term : . term
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    ,               reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

    term                           shift and go to state 79
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    id                             shift and go to state 20
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 69

    (19) exp -> term binop exp .

    FN              reduce using rule 19 (exp -> term binop exp .)
    COMMAND         reduce using rule 19 (exp -> term binop exp .)
    HANDLER         reduce using rule 19 (exp -> term binop exp .)
    ID              reduce using rule 19 (exp -> term binop exp .)
    $end            reduce using rule 19 (exp -> term binop exp .)
    }               reduce using rule 19 (exp -> term binop exp .)
    IF              reduce using rule 19 (exp -> term binop exp .)
    TRY             reduce using rule 19 (exp -> term binop exp .)
    SIGN            reduce using rule 19 (exp -> term binop exp .)
    UNITARY_OPERATOR reduce using rule 19 (exp -> term binop exp .)
    FLOAT           reduce using rule 19 (exp -> term binop exp .)
    INTEGER         reduce using rule 19 (exp -> term binop exp .)
    BOOLEAN         reduce using rule 19 (exp -> term binop exp .)
    STRING          reduce using rule 19 (exp -> term binop exp .)
    [               reduce using rule 19 (exp -> term binop exp .)
    {               reduce using rule 19 (exp -> term binop exp .)
    BINARY_OPERATOR reduce using rule 19 (exp -> term binop exp .)


state 70

    (21) exp -> IF exp { . body } ELSE { body }
    (22) exp -> IF exp { . body }
    (15) body -> . body exp
    (16) body -> . body variable
    (17) body -> . exp
    (18) body -> . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    exp                            shift and go to state 72
    body                           shift and go to state 80
    variable                       shift and go to state 73
    term                           shift and go to state 40
    id                             shift and go to state 74
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 71

    (23) exp -> TRY { body . } CATCH { body }
    (15) body -> body . exp
    (16) body -> body . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 81
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! }               [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    exp                            shift and go to state 82
    variable                       shift and go to state 83
    term                           shift and go to state 40
    id                             shift and go to state 74
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 72

    (17) body -> exp .

    }               reduce using rule 17 (body -> exp .)
    IF              reduce using rule 17 (body -> exp .)
    TRY             reduce using rule 17 (body -> exp .)
    ID              reduce using rule 17 (body -> exp .)
    SIGN            reduce using rule 17 (body -> exp .)
    UNITARY_OPERATOR reduce using rule 17 (body -> exp .)
    FLOAT           reduce using rule 17 (body -> exp .)
    INTEGER         reduce using rule 17 (body -> exp .)
    BOOLEAN         reduce using rule 17 (body -> exp .)
    STRING          reduce using rule 17 (body -> exp .)
    [               reduce using rule 17 (body -> exp .)
    {               reduce using rule 17 (body -> exp .)
    BINARY_OPERATOR reduce using rule 17 (body -> exp .)


state 73

    (18) body -> variable .

    }               reduce using rule 18 (body -> variable .)
    IF              reduce using rule 18 (body -> variable .)
    TRY             reduce using rule 18 (body -> variable .)
    ID              reduce using rule 18 (body -> variable .)
    SIGN            reduce using rule 18 (body -> variable .)
    UNITARY_OPERATOR reduce using rule 18 (body -> variable .)
    FLOAT           reduce using rule 18 (body -> variable .)
    INTEGER         reduce using rule 18 (body -> variable .)
    BOOLEAN         reduce using rule 18 (body -> variable .)
    STRING          reduce using rule 18 (body -> variable .)
    [               reduce using rule 18 (body -> variable .)
    {               reduce using rule 18 (body -> variable .)
    BINARY_OPERATOR reduce using rule 18 (body -> variable .)


state 74

    (24) variable -> id . = exp
    (34) term -> id .
    (11) function_call -> id . ( term_list )

    =               shift and go to state 16
    SIGN            reduce using rule 34 (term -> id .)
    BINARY_OPERATOR reduce using rule 34 (term -> id .)
    }               reduce using rule 34 (term -> id .)
    IF              reduce using rule 34 (term -> id .)
    TRY             reduce using rule 34 (term -> id .)
    ID              reduce using rule 34 (term -> id .)
    UNITARY_OPERATOR reduce using rule 34 (term -> id .)
    FLOAT           reduce using rule 34 (term -> id .)
    INTEGER         reduce using rule 34 (term -> id .)
    BOOLEAN         reduce using rule 34 (term -> id .)
    STRING          reduce using rule 34 (term -> id .)
    [               reduce using rule 34 (term -> id .)
    {               reduce using rule 34 (term -> id .)
    (               shift and go to state 15


state 75

    (9) function -> COMMAND id ( parameter ) . { body }

    {               shift and go to state 84


state 76

    (10) function -> HANDLER id ( parameter ) . { body }

    {               shift and go to state 85


state 77

    (12) parameter -> id , parameter .

    )               reduce using rule 12 (parameter -> id , parameter .)


state 78

    (8) function -> FN id ( parameter ) { . body }
    (15) body -> . body exp
    (16) body -> . body variable
    (17) body -> . exp
    (18) body -> . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    id                             shift and go to state 74
    body                           shift and go to state 86
    exp                            shift and go to state 72
    variable                       shift and go to state 73
    term                           shift and go to state 40
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 79

    (25) term_map -> term : term . , term_map
    (26) term_map -> term : term .

    ,               shift and go to state 87
    }               reduce using rule 26 (term_map -> term : term .)


state 80

    (21) exp -> IF exp { body . } ELSE { body }
    (22) exp -> IF exp { body . }
    (15) body -> body . exp
    (16) body -> body . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 88
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! }               [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    exp                            shift and go to state 82
    variable                       shift and go to state 83
    term                           shift and go to state 40
    id                             shift and go to state 74
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 81

    (23) exp -> TRY { body } . CATCH { body }

    CATCH           shift and go to state 89


state 82

    (15) body -> body exp .

    }               reduce using rule 15 (body -> body exp .)
    IF              reduce using rule 15 (body -> body exp .)
    TRY             reduce using rule 15 (body -> body exp .)
    ID              reduce using rule 15 (body -> body exp .)
    SIGN            reduce using rule 15 (body -> body exp .)
    UNITARY_OPERATOR reduce using rule 15 (body -> body exp .)
    FLOAT           reduce using rule 15 (body -> body exp .)
    INTEGER         reduce using rule 15 (body -> body exp .)
    BOOLEAN         reduce using rule 15 (body -> body exp .)
    STRING          reduce using rule 15 (body -> body exp .)
    [               reduce using rule 15 (body -> body exp .)
    {               reduce using rule 15 (body -> body exp .)
    BINARY_OPERATOR reduce using rule 15 (body -> body exp .)


state 83

    (16) body -> body variable .

    }               reduce using rule 16 (body -> body variable .)
    IF              reduce using rule 16 (body -> body variable .)
    TRY             reduce using rule 16 (body -> body variable .)
    ID              reduce using rule 16 (body -> body variable .)
    SIGN            reduce using rule 16 (body -> body variable .)
    UNITARY_OPERATOR reduce using rule 16 (body -> body variable .)
    FLOAT           reduce using rule 16 (body -> body variable .)
    INTEGER         reduce using rule 16 (body -> body variable .)
    BOOLEAN         reduce using rule 16 (body -> body variable .)
    STRING          reduce using rule 16 (body -> body variable .)
    [               reduce using rule 16 (body -> body variable .)
    {               reduce using rule 16 (body -> body variable .)
    BINARY_OPERATOR reduce using rule 16 (body -> body variable .)


state 84

    (9) function -> COMMAND id ( parameter ) { . body }
    (15) body -> . body exp
    (16) body -> . body variable
    (17) body -> . exp
    (18) body -> . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    id                             shift and go to state 74
    body                           shift and go to state 90
    exp                            shift and go to state 72
    variable                       shift and go to state 73
    term                           shift and go to state 40
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 85

    (10) function -> HANDLER id ( parameter ) { . body }
    (15) body -> . body exp
    (16) body -> . body variable
    (17) body -> . exp
    (18) body -> . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    id                             shift and go to state 74
    body                           shift and go to state 91
    exp                            shift and go to state 72
    variable                       shift and go to state 73
    term                           shift and go to state 40
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 86

    (8) function -> FN id ( parameter ) { body . }
    (15) body -> body . exp
    (16) body -> body . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 92
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! }               [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    id                             shift and go to state 74
    exp                            shift and go to state 82
    variable                       shift and go to state 83
    term                           shift and go to state 40
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 87

    (25) term_map -> term : term , . term_map
    (25) term_map -> . term : term , term_map
    (26) term_map -> . term : term
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (49) id -> . ID
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    ID              shift and go to state 10
    [               shift and go to state 37
    {               shift and go to state 38
    :               reduce using rule 50 (empty -> .)

    term                           shift and go to state 54
    term_map                       shift and go to state 93
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    id                             shift and go to state 20
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 88

    (21) exp -> IF exp { body } . ELSE { body }
    (22) exp -> IF exp { body } .

    ELSE            shift and go to state 94
    FN              reduce using rule 22 (exp -> IF exp { body } .)
    COMMAND         reduce using rule 22 (exp -> IF exp { body } .)
    HANDLER         reduce using rule 22 (exp -> IF exp { body } .)
    ID              reduce using rule 22 (exp -> IF exp { body } .)
    $end            reduce using rule 22 (exp -> IF exp { body } .)
    }               reduce using rule 22 (exp -> IF exp { body } .)
    IF              reduce using rule 22 (exp -> IF exp { body } .)
    TRY             reduce using rule 22 (exp -> IF exp { body } .)
    SIGN            reduce using rule 22 (exp -> IF exp { body } .)
    UNITARY_OPERATOR reduce using rule 22 (exp -> IF exp { body } .)
    FLOAT           reduce using rule 22 (exp -> IF exp { body } .)
    INTEGER         reduce using rule 22 (exp -> IF exp { body } .)
    BOOLEAN         reduce using rule 22 (exp -> IF exp { body } .)
    STRING          reduce using rule 22 (exp -> IF exp { body } .)
    [               reduce using rule 22 (exp -> IF exp { body } .)
    {               reduce using rule 22 (exp -> IF exp { body } .)
    BINARY_OPERATOR reduce using rule 22 (exp -> IF exp { body } .)


state 89

    (23) exp -> TRY { body } CATCH . { body }

    {               shift and go to state 95


state 90

    (9) function -> COMMAND id ( parameter ) { body . }
    (15) body -> body . exp
    (16) body -> body . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 96
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! }               [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    id                             shift and go to state 74
    exp                            shift and go to state 82
    variable                       shift and go to state 83
    term                           shift and go to state 40
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 91

    (10) function -> HANDLER id ( parameter ) { body . }
    (15) body -> body . exp
    (16) body -> body . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 97
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! }               [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    id                             shift and go to state 74
    exp                            shift and go to state 82
    variable                       shift and go to state 83
    term                           shift and go to state 40
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 92

    (8) function -> FN id ( parameter ) { body } .

    FN              reduce using rule 8 (function -> FN id ( parameter ) { body } .)
    COMMAND         reduce using rule 8 (function -> FN id ( parameter ) { body } .)
    HANDLER         reduce using rule 8 (function -> FN id ( parameter ) { body } .)
    ID              reduce using rule 8 (function -> FN id ( parameter ) { body } .)
    $end            reduce using rule 8 (function -> FN id ( parameter ) { body } .)


state 93

    (25) term_map -> term : term , term_map .

    }               reduce using rule 25 (term_map -> term : term , term_map .)


state 94

    (21) exp -> IF exp { body } ELSE . { body }

    {               shift and go to state 98


state 95

    (23) exp -> TRY { body } CATCH { . body }
    (15) body -> . body exp
    (16) body -> . body variable
    (17) body -> . exp
    (18) body -> . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    body                           shift and go to state 99
    exp                            shift and go to state 72
    variable                       shift and go to state 73
    term                           shift and go to state 40
    id                             shift and go to state 74
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 96

    (9) function -> COMMAND id ( parameter ) { body } .

    FN              reduce using rule 9 (function -> COMMAND id ( parameter ) { body } .)
    COMMAND         reduce using rule 9 (function -> COMMAND id ( parameter ) { body } .)
    HANDLER         reduce using rule 9 (function -> COMMAND id ( parameter ) { body } .)
    ID              reduce using rule 9 (function -> COMMAND id ( parameter ) { body } .)
    $end            reduce using rule 9 (function -> COMMAND id ( parameter ) { body } .)


state 97

    (10) function -> HANDLER id ( parameter ) { body } .

    FN              reduce using rule 10 (function -> HANDLER id ( parameter ) { body } .)
    COMMAND         reduce using rule 10 (function -> HANDLER id ( parameter ) { body } .)
    HANDLER         reduce using rule 10 (function -> HANDLER id ( parameter ) { body } .)
    ID              reduce using rule 10 (function -> HANDLER id ( parameter ) { body } .)
    $end            reduce using rule 10 (function -> HANDLER id ( parameter ) { body } .)


state 98

    (21) exp -> IF exp { body } ELSE { . body }
    (15) body -> . body exp
    (16) body -> . body variable
    (17) body -> . exp
    (18) body -> . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)
    }               reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    exp                            shift and go to state 72
    body                           shift and go to state 100
    variable                       shift and go to state 73
    term                           shift and go to state 40
    id                             shift and go to state 74
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 99

    (23) exp -> TRY { body } CATCH { body . }
    (15) body -> body . exp
    (16) body -> body . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 101
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! }               [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    exp                            shift and go to state 82
    variable                       shift and go to state 83
    term                           shift and go to state 40
    id                             shift and go to state 74
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 100

    (21) exp -> IF exp { body } ELSE { body . }
    (15) body -> body . exp
    (16) body -> body . variable
    (19) exp -> . term binop exp
    (20) exp -> . term
    (21) exp -> . IF exp { body } ELSE { body }
    (22) exp -> . IF exp { body }
    (23) exp -> . TRY { body } CATCH { body }
    (24) variable -> . id = exp
    (29) term -> . unop term
    (30) term -> . number
    (31) term -> . boolean
    (32) term -> . string
    (33) term -> . function_call
    (34) term -> . id
    (35) term -> . list
    (36) term -> . dict
    (37) term -> . empty
    (49) id -> . ID
    (38) unop -> . SIGN
    (39) unop -> . UNITARY_OPERATOR
    (45) number -> . FLOAT
    (46) number -> . INTEGER
    (47) boolean -> . BOOLEAN
    (48) string -> . STRING
    (11) function_call -> . id ( term_list )
    (44) list -> . [ term_list ]
    (42) dict -> . { term_map }
    (43) dict -> . { empty }
    (50) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 102
    IF              shift and go to state 41
    TRY             shift and go to state 42
    ID              shift and go to state 10
    SIGN            shift and go to state 31
    UNITARY_OPERATOR shift and go to state 32
    FLOAT           shift and go to state 33
    INTEGER         shift and go to state 34
    BOOLEAN         shift and go to state 35
    STRING          shift and go to state 36
    [               shift and go to state 37
    {               shift and go to state 38
    BINARY_OPERATOR reduce using rule 50 (empty -> .)

  ! SIGN            [ reduce using rule 50 (empty -> .) ]
  ! }               [ reduce using rule 50 (empty -> .) ]
  ! IF              [ reduce using rule 50 (empty -> .) ]
  ! TRY             [ reduce using rule 50 (empty -> .) ]
  ! ID              [ reduce using rule 50 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 50 (empty -> .) ]
  ! FLOAT           [ reduce using rule 50 (empty -> .) ]
  ! INTEGER         [ reduce using rule 50 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 50 (empty -> .) ]
  ! STRING          [ reduce using rule 50 (empty -> .) ]
  ! [               [ reduce using rule 50 (empty -> .) ]
  ! {               [ reduce using rule 50 (empty -> .) ]

    exp                            shift and go to state 82
    variable                       shift and go to state 83
    term                           shift and go to state 40
    id                             shift and go to state 74
    unop                           shift and go to state 23
    number                         shift and go to state 24
    boolean                        shift and go to state 25
    string                         shift and go to state 26
    function_call                  shift and go to state 27
    list                           shift and go to state 28
    dict                           shift and go to state 29
    empty                          shift and go to state 30

state 101

    (23) exp -> TRY { body } CATCH { body } .

    FN              reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    COMMAND         reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    HANDLER         reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    ID              reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    $end            reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    }               reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    IF              reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    TRY             reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    SIGN            reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    UNITARY_OPERATOR reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    FLOAT           reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    INTEGER         reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    BOOLEAN         reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    STRING          reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    [               reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    {               reduce using rule 23 (exp -> TRY { body } CATCH { body } .)
    BINARY_OPERATOR reduce using rule 23 (exp -> TRY { body } CATCH { body } .)


state 102

    (21) exp -> IF exp { body } ELSE { body } .

    FN              reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    COMMAND         reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    HANDLER         reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    ID              reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    $end            reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    }               reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    IF              reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    TRY             reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    SIGN            reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    UNITARY_OPERATOR reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    FLOAT           reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    INTEGER         reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    BOOLEAN         reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    STRING          reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    [               reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    {               reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)
    BINARY_OPERATOR reduce using rule 21 (exp -> IF exp { body } ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SIGN in state 16 resolved as shift
WARNING: shift/reduce conflict for ID in state 16 resolved as shift
WARNING: shift/reduce conflict for IF in state 16 resolved as shift
WARNING: shift/reduce conflict for TRY in state 16 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 16 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 16 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 16 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 16 resolved as shift
WARNING: shift/reduce conflict for STRING in state 16 resolved as shift
WARNING: shift/reduce conflict for [ in state 16 resolved as shift
WARNING: shift/reduce conflict for { in state 16 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 23 resolved as shift
WARNING: shift/reduce conflict for ID in state 23 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 23 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 23 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 23 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 23 resolved as shift
WARNING: shift/reduce conflict for STRING in state 23 resolved as shift
WARNING: shift/reduce conflict for [ in state 23 resolved as shift
WARNING: shift/reduce conflict for { in state 23 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 40 resolved as shift
WARNING: shift/reduce conflict for BINARY_OPERATOR in state 40 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 41 resolved as shift
WARNING: shift/reduce conflict for { in state 41 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 55 resolved as shift
WARNING: shift/reduce conflict for ID in state 55 resolved as shift
WARNING: shift/reduce conflict for IF in state 55 resolved as shift
WARNING: shift/reduce conflict for TRY in state 55 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 55 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 55 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 55 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 55 resolved as shift
WARNING: shift/reduce conflict for STRING in state 55 resolved as shift
WARNING: shift/reduce conflict for [ in state 55 resolved as shift
WARNING: shift/reduce conflict for { in state 55 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 59 resolved as shift
WARNING: shift/reduce conflict for IF in state 59 resolved as shift
WARNING: shift/reduce conflict for TRY in state 59 resolved as shift
WARNING: shift/reduce conflict for ID in state 59 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 59 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 59 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 59 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 59 resolved as shift
WARNING: shift/reduce conflict for STRING in state 59 resolved as shift
WARNING: shift/reduce conflict for [ in state 59 resolved as shift
WARNING: shift/reduce conflict for { in state 59 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 70 resolved as shift
WARNING: shift/reduce conflict for IF in state 70 resolved as shift
WARNING: shift/reduce conflict for TRY in state 70 resolved as shift
WARNING: shift/reduce conflict for ID in state 70 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 70 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 70 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 70 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 70 resolved as shift
WARNING: shift/reduce conflict for STRING in state 70 resolved as shift
WARNING: shift/reduce conflict for [ in state 70 resolved as shift
WARNING: shift/reduce conflict for { in state 70 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 71 resolved as shift
WARNING: shift/reduce conflict for } in state 71 resolved as shift
WARNING: shift/reduce conflict for IF in state 71 resolved as shift
WARNING: shift/reduce conflict for TRY in state 71 resolved as shift
WARNING: shift/reduce conflict for ID in state 71 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 71 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 71 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 71 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 71 resolved as shift
WARNING: shift/reduce conflict for STRING in state 71 resolved as shift
WARNING: shift/reduce conflict for [ in state 71 resolved as shift
WARNING: shift/reduce conflict for { in state 71 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 78 resolved as shift
WARNING: shift/reduce conflict for IF in state 78 resolved as shift
WARNING: shift/reduce conflict for TRY in state 78 resolved as shift
WARNING: shift/reduce conflict for ID in state 78 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 78 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 78 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 78 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 78 resolved as shift
WARNING: shift/reduce conflict for STRING in state 78 resolved as shift
WARNING: shift/reduce conflict for [ in state 78 resolved as shift
WARNING: shift/reduce conflict for { in state 78 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 80 resolved as shift
WARNING: shift/reduce conflict for } in state 80 resolved as shift
WARNING: shift/reduce conflict for IF in state 80 resolved as shift
WARNING: shift/reduce conflict for TRY in state 80 resolved as shift
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 80 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 80 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 80 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 80 resolved as shift
WARNING: shift/reduce conflict for STRING in state 80 resolved as shift
WARNING: shift/reduce conflict for [ in state 80 resolved as shift
WARNING: shift/reduce conflict for { in state 80 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 84 resolved as shift
WARNING: shift/reduce conflict for IF in state 84 resolved as shift
WARNING: shift/reduce conflict for TRY in state 84 resolved as shift
WARNING: shift/reduce conflict for ID in state 84 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 84 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 84 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 84 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 84 resolved as shift
WARNING: shift/reduce conflict for STRING in state 84 resolved as shift
WARNING: shift/reduce conflict for [ in state 84 resolved as shift
WARNING: shift/reduce conflict for { in state 84 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 85 resolved as shift
WARNING: shift/reduce conflict for IF in state 85 resolved as shift
WARNING: shift/reduce conflict for TRY in state 85 resolved as shift
WARNING: shift/reduce conflict for ID in state 85 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 85 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 85 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 85 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 85 resolved as shift
WARNING: shift/reduce conflict for STRING in state 85 resolved as shift
WARNING: shift/reduce conflict for [ in state 85 resolved as shift
WARNING: shift/reduce conflict for { in state 85 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 86 resolved as shift
WARNING: shift/reduce conflict for } in state 86 resolved as shift
WARNING: shift/reduce conflict for IF in state 86 resolved as shift
WARNING: shift/reduce conflict for TRY in state 86 resolved as shift
WARNING: shift/reduce conflict for ID in state 86 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 86 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 86 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 86 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 86 resolved as shift
WARNING: shift/reduce conflict for STRING in state 86 resolved as shift
WARNING: shift/reduce conflict for [ in state 86 resolved as shift
WARNING: shift/reduce conflict for { in state 86 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 90 resolved as shift
WARNING: shift/reduce conflict for } in state 90 resolved as shift
WARNING: shift/reduce conflict for IF in state 90 resolved as shift
WARNING: shift/reduce conflict for TRY in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 90 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 90 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 90 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 90 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 90 resolved as shift
WARNING: shift/reduce conflict for STRING in state 90 resolved as shift
WARNING: shift/reduce conflict for [ in state 90 resolved as shift
WARNING: shift/reduce conflict for { in state 90 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 91 resolved as shift
WARNING: shift/reduce conflict for } in state 91 resolved as shift
WARNING: shift/reduce conflict for IF in state 91 resolved as shift
WARNING: shift/reduce conflict for TRY in state 91 resolved as shift
WARNING: shift/reduce conflict for ID in state 91 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 91 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 91 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 91 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 91 resolved as shift
WARNING: shift/reduce conflict for STRING in state 91 resolved as shift
WARNING: shift/reduce conflict for [ in state 91 resolved as shift
WARNING: shift/reduce conflict for { in state 91 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 95 resolved as shift
WARNING: shift/reduce conflict for IF in state 95 resolved as shift
WARNING: shift/reduce conflict for TRY in state 95 resolved as shift
WARNING: shift/reduce conflict for ID in state 95 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 95 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 95 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 95 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 95 resolved as shift
WARNING: shift/reduce conflict for STRING in state 95 resolved as shift
WARNING: shift/reduce conflict for [ in state 95 resolved as shift
WARNING: shift/reduce conflict for { in state 95 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 98 resolved as shift
WARNING: shift/reduce conflict for IF in state 98 resolved as shift
WARNING: shift/reduce conflict for TRY in state 98 resolved as shift
WARNING: shift/reduce conflict for ID in state 98 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 98 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 98 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 98 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 98 resolved as shift
WARNING: shift/reduce conflict for STRING in state 98 resolved as shift
WARNING: shift/reduce conflict for [ in state 98 resolved as shift
WARNING: shift/reduce conflict for { in state 98 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 99 resolved as shift
WARNING: shift/reduce conflict for } in state 99 resolved as shift
WARNING: shift/reduce conflict for IF in state 99 resolved as shift
WARNING: shift/reduce conflict for TRY in state 99 resolved as shift
WARNING: shift/reduce conflict for ID in state 99 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 99 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 99 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 99 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 99 resolved as shift
WARNING: shift/reduce conflict for STRING in state 99 resolved as shift
WARNING: shift/reduce conflict for [ in state 99 resolved as shift
WARNING: shift/reduce conflict for { in state 99 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 100 resolved as shift
WARNING: shift/reduce conflict for } in state 100 resolved as shift
WARNING: shift/reduce conflict for IF in state 100 resolved as shift
WARNING: shift/reduce conflict for TRY in state 100 resolved as shift
WARNING: shift/reduce conflict for ID in state 100 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 100 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 100 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 100 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 100 resolved as shift
WARNING: shift/reduce conflict for STRING in state 100 resolved as shift
WARNING: shift/reduce conflict for [ in state 100 resolved as shift
WARNING: shift/reduce conflict for { in state 100 resolved as shift
