Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> exp
Rule 2     program -> function
Rule 3     function -> FN ID ( parameter ) { body }
Rule 4     function -> COMMAND ID ( parameter ) { body }
Rule 5     function -> HANDLER ID ( parameter ) { body }
Rule 6     function_call -> ID ( term_list )
Rule 7     parameter -> ID , parameter
Rule 8     parameter -> ID
Rule 9     parameter -> empty
Rule 10    body -> body exp
Rule 11    body -> body variable
Rule 12    body -> exp
Rule 13    body -> variable
Rule 14    exp -> term binop exp
Rule 15    exp -> term
Rule 16    exp -> IF exp { body } ELSE { body }
Rule 17    exp -> IF exp { body }
Rule 18    exp -> TRY { body } CATCH { body }
Rule 19    variable -> ID = exp
Rule 20    term_map -> term : term , term_map
Rule 21    term_map -> term : term
Rule 22    term_list -> term_list , term
Rule 23    term_list -> term
Rule 24    term -> unop term
Rule 25    term -> number
Rule 26    term -> boolean
Rule 27    term -> string
Rule 28    term -> function_call
Rule 29    term -> ID
Rule 30    term -> list
Rule 31    term -> dict
Rule 32    term -> empty
Rule 33    unop -> SIGN
Rule 34    unop -> UNITARY_OPERATOR
Rule 35    binop -> SIGN
Rule 36    binop -> BINARY_OPERATOR
Rule 37    dict -> { term_map }
Rule 38    dict -> { empty }
Rule 39    list -> [ term_list ]
Rule 40    number -> FLOAT
Rule 41    number -> INTEGER
Rule 42    boolean -> BOOLEAN
Rule 43    string -> STRING
Rule 44    empty -> <empty>

Terminals, with rules where they appear

(                    : 3 4 5 6
)                    : 3 4 5 6
,                    : 7 20 22
:                    : 20 21
=                    : 19
BINARY_OPERATOR      : 36
BOOLEAN              : 42
CATCH                : 18
COMMAND              : 4
ELSE                 : 16
FLOAT                : 40
FN                   : 3
HANDLER              : 5
ID                   : 3 4 5 6 7 8 19 29
IF                   : 16 17
INTEGER              : 41
SIGN                 : 33 35
STRING               : 43
TRY                  : 18
UNITARY_OPERATOR     : 34
[                    : 39
]                    : 39
error                : 
{                    : 3 4 5 16 16 17 18 18 37 38
}                    : 3 4 5 16 16 17 18 18 37 38

Nonterminals, with rules where they appear

binop                : 14
body                 : 3 4 5 10 11 16 16 17 18 18
boolean              : 26
dict                 : 31
empty                : 9 32 38
exp                  : 1 10 12 14 16 17 19
function             : 2
function_call        : 28
list                 : 30
number               : 25
parameter            : 3 4 5 7
program              : 0
string               : 27
term                 : 14 15 20 20 21 21 22 23 24
term_list            : 6 22 39
term_map             : 20 37
unop                 : 24
variable             : 11 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . exp
    (2) program -> . function
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (3) function -> . FN ID ( parameter ) { body }
    (4) function -> . COMMAND ID ( parameter ) { body }
    (5) function -> . HANDLER ID ( parameter ) { body }
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    FN              shift and go to state 8
    COMMAND         shift and go to state 10
    HANDLER         shift and go to state 11
    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    $end            reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]

    program                        shift and go to state 1
    exp                            shift and go to state 2
    function                       shift and go to state 3
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 1

    (0) S' -> program .



state 2

    (1) program -> exp .

    $end            reduce using rule 1 (program -> exp .)


state 3

    (2) program -> function .

    $end            reduce using rule 2 (program -> function .)


state 4

    (14) exp -> term . binop exp
    (15) exp -> term .
    (35) binop -> . SIGN
    (36) binop -> . BINARY_OPERATOR

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for BINARY_OPERATOR resolved as shift
    $end            reduce using rule 15 (exp -> term .)
    {               reduce using rule 15 (exp -> term .)
    }               reduce using rule 15 (exp -> term .)
    IF              reduce using rule 15 (exp -> term .)
    TRY             reduce using rule 15 (exp -> term .)
    ID              reduce using rule 15 (exp -> term .)
    UNITARY_OPERATOR reduce using rule 15 (exp -> term .)
    FLOAT           reduce using rule 15 (exp -> term .)
    INTEGER         reduce using rule 15 (exp -> term .)
    BOOLEAN         reduce using rule 15 (exp -> term .)
    STRING          reduce using rule 15 (exp -> term .)
    [               reduce using rule 15 (exp -> term .)
    SIGN            shift and go to state 28
    BINARY_OPERATOR shift and go to state 29

  ! SIGN            [ reduce using rule 15 (exp -> term .) ]
  ! BINARY_OPERATOR [ reduce using rule 15 (exp -> term .) ]

    binop                          shift and go to state 27

state 5

    (16) exp -> IF . exp { body } ELSE { body }
    (17) exp -> IF . exp { body }
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 30
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 6

    (37) dict -> { . term_map }
    (38) dict -> { . empty }
    (20) term_map -> . term : term , term_map
    (21) term_map -> . term : term
    (44) empty -> .
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }

    }               reduce using rule 44 (empty -> .)
    :               reduce using rule 44 (empty -> .)
    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6

    term_map                       shift and go to state 31
    empty                          shift and go to state 32
    term                           shift and go to state 33
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18

state 7

    (18) exp -> TRY . { body } CATCH { body }

    {               shift and go to state 34


state 8

    (3) function -> FN . ID ( parameter ) { body }

    ID              shift and go to state 35


state 9

    (29) term -> ID .
    (6) function_call -> ID . ( term_list )

    SIGN            reduce using rule 29 (term -> ID .)
    BINARY_OPERATOR reduce using rule 29 (term -> ID .)
    $end            reduce using rule 29 (term -> ID .)
    {               reduce using rule 29 (term -> ID .)
    :               reduce using rule 29 (term -> ID .)
    ]               reduce using rule 29 (term -> ID .)
    ,               reduce using rule 29 (term -> ID .)
    }               reduce using rule 29 (term -> ID .)
    IF              reduce using rule 29 (term -> ID .)
    TRY             reduce using rule 29 (term -> ID .)
    ID              reduce using rule 29 (term -> ID .)
    UNITARY_OPERATOR reduce using rule 29 (term -> ID .)
    FLOAT           reduce using rule 29 (term -> ID .)
    INTEGER         reduce using rule 29 (term -> ID .)
    BOOLEAN         reduce using rule 29 (term -> ID .)
    STRING          reduce using rule 29 (term -> ID .)
    [               reduce using rule 29 (term -> ID .)
    )               reduce using rule 29 (term -> ID .)
    (               shift and go to state 36


state 10

    (4) function -> COMMAND . ID ( parameter ) { body }

    ID              shift and go to state 37


state 11

    (5) function -> HANDLER . ID ( parameter ) { body }

    ID              shift and go to state 38


state 12

    (24) term -> unop . term
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    $end            reduce using rule 44 (empty -> .)
    :               reduce using rule 44 (empty -> .)
    ]               reduce using rule 44 (empty -> .)
    ,               reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)
    IF              reduce using rule 44 (empty -> .)
    TRY             reduce using rule 44 (empty -> .)
    )               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]

    unop                           shift and go to state 12
    term                           shift and go to state 39
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 13

    (25) term -> number .

    SIGN            reduce using rule 25 (term -> number .)
    BINARY_OPERATOR reduce using rule 25 (term -> number .)
    $end            reduce using rule 25 (term -> number .)
    {               reduce using rule 25 (term -> number .)
    :               reduce using rule 25 (term -> number .)
    ]               reduce using rule 25 (term -> number .)
    ,               reduce using rule 25 (term -> number .)
    }               reduce using rule 25 (term -> number .)
    IF              reduce using rule 25 (term -> number .)
    TRY             reduce using rule 25 (term -> number .)
    ID              reduce using rule 25 (term -> number .)
    UNITARY_OPERATOR reduce using rule 25 (term -> number .)
    FLOAT           reduce using rule 25 (term -> number .)
    INTEGER         reduce using rule 25 (term -> number .)
    BOOLEAN         reduce using rule 25 (term -> number .)
    STRING          reduce using rule 25 (term -> number .)
    [               reduce using rule 25 (term -> number .)
    )               reduce using rule 25 (term -> number .)


state 14

    (26) term -> boolean .

    SIGN            reduce using rule 26 (term -> boolean .)
    BINARY_OPERATOR reduce using rule 26 (term -> boolean .)
    $end            reduce using rule 26 (term -> boolean .)
    {               reduce using rule 26 (term -> boolean .)
    :               reduce using rule 26 (term -> boolean .)
    ]               reduce using rule 26 (term -> boolean .)
    ,               reduce using rule 26 (term -> boolean .)
    }               reduce using rule 26 (term -> boolean .)
    IF              reduce using rule 26 (term -> boolean .)
    TRY             reduce using rule 26 (term -> boolean .)
    ID              reduce using rule 26 (term -> boolean .)
    UNITARY_OPERATOR reduce using rule 26 (term -> boolean .)
    FLOAT           reduce using rule 26 (term -> boolean .)
    INTEGER         reduce using rule 26 (term -> boolean .)
    BOOLEAN         reduce using rule 26 (term -> boolean .)
    STRING          reduce using rule 26 (term -> boolean .)
    [               reduce using rule 26 (term -> boolean .)
    )               reduce using rule 26 (term -> boolean .)


state 15

    (27) term -> string .

    SIGN            reduce using rule 27 (term -> string .)
    BINARY_OPERATOR reduce using rule 27 (term -> string .)
    $end            reduce using rule 27 (term -> string .)
    {               reduce using rule 27 (term -> string .)
    :               reduce using rule 27 (term -> string .)
    ]               reduce using rule 27 (term -> string .)
    ,               reduce using rule 27 (term -> string .)
    }               reduce using rule 27 (term -> string .)
    IF              reduce using rule 27 (term -> string .)
    TRY             reduce using rule 27 (term -> string .)
    ID              reduce using rule 27 (term -> string .)
    UNITARY_OPERATOR reduce using rule 27 (term -> string .)
    FLOAT           reduce using rule 27 (term -> string .)
    INTEGER         reduce using rule 27 (term -> string .)
    BOOLEAN         reduce using rule 27 (term -> string .)
    STRING          reduce using rule 27 (term -> string .)
    [               reduce using rule 27 (term -> string .)
    )               reduce using rule 27 (term -> string .)


state 16

    (28) term -> function_call .

    SIGN            reduce using rule 28 (term -> function_call .)
    BINARY_OPERATOR reduce using rule 28 (term -> function_call .)
    $end            reduce using rule 28 (term -> function_call .)
    {               reduce using rule 28 (term -> function_call .)
    :               reduce using rule 28 (term -> function_call .)
    ]               reduce using rule 28 (term -> function_call .)
    ,               reduce using rule 28 (term -> function_call .)
    }               reduce using rule 28 (term -> function_call .)
    IF              reduce using rule 28 (term -> function_call .)
    TRY             reduce using rule 28 (term -> function_call .)
    ID              reduce using rule 28 (term -> function_call .)
    UNITARY_OPERATOR reduce using rule 28 (term -> function_call .)
    FLOAT           reduce using rule 28 (term -> function_call .)
    INTEGER         reduce using rule 28 (term -> function_call .)
    BOOLEAN         reduce using rule 28 (term -> function_call .)
    STRING          reduce using rule 28 (term -> function_call .)
    [               reduce using rule 28 (term -> function_call .)
    )               reduce using rule 28 (term -> function_call .)


state 17

    (30) term -> list .

    SIGN            reduce using rule 30 (term -> list .)
    BINARY_OPERATOR reduce using rule 30 (term -> list .)
    $end            reduce using rule 30 (term -> list .)
    {               reduce using rule 30 (term -> list .)
    :               reduce using rule 30 (term -> list .)
    ]               reduce using rule 30 (term -> list .)
    ,               reduce using rule 30 (term -> list .)
    }               reduce using rule 30 (term -> list .)
    IF              reduce using rule 30 (term -> list .)
    TRY             reduce using rule 30 (term -> list .)
    ID              reduce using rule 30 (term -> list .)
    UNITARY_OPERATOR reduce using rule 30 (term -> list .)
    FLOAT           reduce using rule 30 (term -> list .)
    INTEGER         reduce using rule 30 (term -> list .)
    BOOLEAN         reduce using rule 30 (term -> list .)
    STRING          reduce using rule 30 (term -> list .)
    [               reduce using rule 30 (term -> list .)
    )               reduce using rule 30 (term -> list .)


state 18

    (31) term -> dict .

    SIGN            reduce using rule 31 (term -> dict .)
    BINARY_OPERATOR reduce using rule 31 (term -> dict .)
    $end            reduce using rule 31 (term -> dict .)
    {               reduce using rule 31 (term -> dict .)
    :               reduce using rule 31 (term -> dict .)
    ]               reduce using rule 31 (term -> dict .)
    ,               reduce using rule 31 (term -> dict .)
    }               reduce using rule 31 (term -> dict .)
    IF              reduce using rule 31 (term -> dict .)
    TRY             reduce using rule 31 (term -> dict .)
    ID              reduce using rule 31 (term -> dict .)
    UNITARY_OPERATOR reduce using rule 31 (term -> dict .)
    FLOAT           reduce using rule 31 (term -> dict .)
    INTEGER         reduce using rule 31 (term -> dict .)
    BOOLEAN         reduce using rule 31 (term -> dict .)
    STRING          reduce using rule 31 (term -> dict .)
    [               reduce using rule 31 (term -> dict .)
    )               reduce using rule 31 (term -> dict .)


state 19

    (32) term -> empty .

    SIGN            reduce using rule 32 (term -> empty .)
    BINARY_OPERATOR reduce using rule 32 (term -> empty .)
    $end            reduce using rule 32 (term -> empty .)
    {               reduce using rule 32 (term -> empty .)
    :               reduce using rule 32 (term -> empty .)
    ]               reduce using rule 32 (term -> empty .)
    ,               reduce using rule 32 (term -> empty .)
    }               reduce using rule 32 (term -> empty .)
    IF              reduce using rule 32 (term -> empty .)
    TRY             reduce using rule 32 (term -> empty .)
    ID              reduce using rule 32 (term -> empty .)
    UNITARY_OPERATOR reduce using rule 32 (term -> empty .)
    FLOAT           reduce using rule 32 (term -> empty .)
    INTEGER         reduce using rule 32 (term -> empty .)
    BOOLEAN         reduce using rule 32 (term -> empty .)
    STRING          reduce using rule 32 (term -> empty .)
    [               reduce using rule 32 (term -> empty .)
    )               reduce using rule 32 (term -> empty .)


state 20

    (33) unop -> SIGN .

    ID              reduce using rule 33 (unop -> SIGN .)
    SIGN            reduce using rule 33 (unop -> SIGN .)
    UNITARY_OPERATOR reduce using rule 33 (unop -> SIGN .)
    FLOAT           reduce using rule 33 (unop -> SIGN .)
    INTEGER         reduce using rule 33 (unop -> SIGN .)
    BOOLEAN         reduce using rule 33 (unop -> SIGN .)
    STRING          reduce using rule 33 (unop -> SIGN .)
    [               reduce using rule 33 (unop -> SIGN .)
    {               reduce using rule 33 (unop -> SIGN .)
    BINARY_OPERATOR reduce using rule 33 (unop -> SIGN .)
    $end            reduce using rule 33 (unop -> SIGN .)
    :               reduce using rule 33 (unop -> SIGN .)
    ]               reduce using rule 33 (unop -> SIGN .)
    ,               reduce using rule 33 (unop -> SIGN .)
    }               reduce using rule 33 (unop -> SIGN .)
    IF              reduce using rule 33 (unop -> SIGN .)
    TRY             reduce using rule 33 (unop -> SIGN .)
    )               reduce using rule 33 (unop -> SIGN .)


state 21

    (34) unop -> UNITARY_OPERATOR .

    ID              reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    SIGN            reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    UNITARY_OPERATOR reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    FLOAT           reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    INTEGER         reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    BOOLEAN         reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    STRING          reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    [               reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    {               reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    BINARY_OPERATOR reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    $end            reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    :               reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    ]               reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    ,               reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    }               reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    IF              reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    TRY             reduce using rule 34 (unop -> UNITARY_OPERATOR .)
    )               reduce using rule 34 (unop -> UNITARY_OPERATOR .)


state 22

    (40) number -> FLOAT .

    SIGN            reduce using rule 40 (number -> FLOAT .)
    BINARY_OPERATOR reduce using rule 40 (number -> FLOAT .)
    $end            reduce using rule 40 (number -> FLOAT .)
    {               reduce using rule 40 (number -> FLOAT .)
    :               reduce using rule 40 (number -> FLOAT .)
    ]               reduce using rule 40 (number -> FLOAT .)
    ,               reduce using rule 40 (number -> FLOAT .)
    }               reduce using rule 40 (number -> FLOAT .)
    IF              reduce using rule 40 (number -> FLOAT .)
    TRY             reduce using rule 40 (number -> FLOAT .)
    ID              reduce using rule 40 (number -> FLOAT .)
    UNITARY_OPERATOR reduce using rule 40 (number -> FLOAT .)
    FLOAT           reduce using rule 40 (number -> FLOAT .)
    INTEGER         reduce using rule 40 (number -> FLOAT .)
    BOOLEAN         reduce using rule 40 (number -> FLOAT .)
    STRING          reduce using rule 40 (number -> FLOAT .)
    [               reduce using rule 40 (number -> FLOAT .)
    )               reduce using rule 40 (number -> FLOAT .)


state 23

    (41) number -> INTEGER .

    SIGN            reduce using rule 41 (number -> INTEGER .)
    BINARY_OPERATOR reduce using rule 41 (number -> INTEGER .)
    $end            reduce using rule 41 (number -> INTEGER .)
    {               reduce using rule 41 (number -> INTEGER .)
    :               reduce using rule 41 (number -> INTEGER .)
    ]               reduce using rule 41 (number -> INTEGER .)
    ,               reduce using rule 41 (number -> INTEGER .)
    }               reduce using rule 41 (number -> INTEGER .)
    IF              reduce using rule 41 (number -> INTEGER .)
    TRY             reduce using rule 41 (number -> INTEGER .)
    ID              reduce using rule 41 (number -> INTEGER .)
    UNITARY_OPERATOR reduce using rule 41 (number -> INTEGER .)
    FLOAT           reduce using rule 41 (number -> INTEGER .)
    INTEGER         reduce using rule 41 (number -> INTEGER .)
    BOOLEAN         reduce using rule 41 (number -> INTEGER .)
    STRING          reduce using rule 41 (number -> INTEGER .)
    [               reduce using rule 41 (number -> INTEGER .)
    )               reduce using rule 41 (number -> INTEGER .)


state 24

    (42) boolean -> BOOLEAN .

    SIGN            reduce using rule 42 (boolean -> BOOLEAN .)
    BINARY_OPERATOR reduce using rule 42 (boolean -> BOOLEAN .)
    $end            reduce using rule 42 (boolean -> BOOLEAN .)
    {               reduce using rule 42 (boolean -> BOOLEAN .)
    :               reduce using rule 42 (boolean -> BOOLEAN .)
    ]               reduce using rule 42 (boolean -> BOOLEAN .)
    ,               reduce using rule 42 (boolean -> BOOLEAN .)
    }               reduce using rule 42 (boolean -> BOOLEAN .)
    IF              reduce using rule 42 (boolean -> BOOLEAN .)
    TRY             reduce using rule 42 (boolean -> BOOLEAN .)
    ID              reduce using rule 42 (boolean -> BOOLEAN .)
    UNITARY_OPERATOR reduce using rule 42 (boolean -> BOOLEAN .)
    FLOAT           reduce using rule 42 (boolean -> BOOLEAN .)
    INTEGER         reduce using rule 42 (boolean -> BOOLEAN .)
    BOOLEAN         reduce using rule 42 (boolean -> BOOLEAN .)
    STRING          reduce using rule 42 (boolean -> BOOLEAN .)
    [               reduce using rule 42 (boolean -> BOOLEAN .)
    )               reduce using rule 42 (boolean -> BOOLEAN .)


state 25

    (43) string -> STRING .

    SIGN            reduce using rule 43 (string -> STRING .)
    BINARY_OPERATOR reduce using rule 43 (string -> STRING .)
    $end            reduce using rule 43 (string -> STRING .)
    {               reduce using rule 43 (string -> STRING .)
    :               reduce using rule 43 (string -> STRING .)
    ]               reduce using rule 43 (string -> STRING .)
    ,               reduce using rule 43 (string -> STRING .)
    }               reduce using rule 43 (string -> STRING .)
    IF              reduce using rule 43 (string -> STRING .)
    TRY             reduce using rule 43 (string -> STRING .)
    ID              reduce using rule 43 (string -> STRING .)
    UNITARY_OPERATOR reduce using rule 43 (string -> STRING .)
    FLOAT           reduce using rule 43 (string -> STRING .)
    INTEGER         reduce using rule 43 (string -> STRING .)
    BOOLEAN         reduce using rule 43 (string -> STRING .)
    STRING          reduce using rule 43 (string -> STRING .)
    [               reduce using rule 43 (string -> STRING .)
    )               reduce using rule 43 (string -> STRING .)


state 26

    (39) list -> [ . term_list ]
    (22) term_list -> . term_list , term
    (23) term_list -> . term
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    ]               reduce using rule 44 (empty -> .)
    ,               reduce using rule 44 (empty -> .)

    term_list                      shift and go to state 40
    term                           shift and go to state 41
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 27

    (14) exp -> term binop . exp
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    $end            reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]

    term                           shift and go to state 4
    exp                            shift and go to state 42
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 28

    (35) binop -> SIGN .

    IF              reduce using rule 35 (binop -> SIGN .)
    TRY             reduce using rule 35 (binop -> SIGN .)
    ID              reduce using rule 35 (binop -> SIGN .)
    SIGN            reduce using rule 35 (binop -> SIGN .)
    UNITARY_OPERATOR reduce using rule 35 (binop -> SIGN .)
    FLOAT           reduce using rule 35 (binop -> SIGN .)
    INTEGER         reduce using rule 35 (binop -> SIGN .)
    BOOLEAN         reduce using rule 35 (binop -> SIGN .)
    STRING          reduce using rule 35 (binop -> SIGN .)
    [               reduce using rule 35 (binop -> SIGN .)
    {               reduce using rule 35 (binop -> SIGN .)
    BINARY_OPERATOR reduce using rule 35 (binop -> SIGN .)
    $end            reduce using rule 35 (binop -> SIGN .)
    }               reduce using rule 35 (binop -> SIGN .)


state 29

    (36) binop -> BINARY_OPERATOR .

    IF              reduce using rule 36 (binop -> BINARY_OPERATOR .)
    TRY             reduce using rule 36 (binop -> BINARY_OPERATOR .)
    ID              reduce using rule 36 (binop -> BINARY_OPERATOR .)
    SIGN            reduce using rule 36 (binop -> BINARY_OPERATOR .)
    UNITARY_OPERATOR reduce using rule 36 (binop -> BINARY_OPERATOR .)
    FLOAT           reduce using rule 36 (binop -> BINARY_OPERATOR .)
    INTEGER         reduce using rule 36 (binop -> BINARY_OPERATOR .)
    BOOLEAN         reduce using rule 36 (binop -> BINARY_OPERATOR .)
    STRING          reduce using rule 36 (binop -> BINARY_OPERATOR .)
    [               reduce using rule 36 (binop -> BINARY_OPERATOR .)
    {               reduce using rule 36 (binop -> BINARY_OPERATOR .)
    BINARY_OPERATOR reduce using rule 36 (binop -> BINARY_OPERATOR .)
    $end            reduce using rule 36 (binop -> BINARY_OPERATOR .)
    }               reduce using rule 36 (binop -> BINARY_OPERATOR .)


state 30

    (16) exp -> IF exp . { body } ELSE { body }
    (17) exp -> IF exp . { body }

    {               shift and go to state 43


state 31

    (37) dict -> { term_map . }

    }               shift and go to state 44


state 32

    (38) dict -> { empty . }
    (32) term -> empty .

    }               shift and go to state 45
    :               reduce using rule 32 (term -> empty .)


state 33

    (20) term_map -> term . : term , term_map
    (21) term_map -> term . : term

    :               shift and go to state 46


state 34

    (18) exp -> TRY { . body } CATCH { body }
    (10) body -> . body exp
    (11) body -> . body variable
    (12) body -> . exp
    (13) body -> . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    body                           shift and go to state 47
    exp                            shift and go to state 48
    variable                       shift and go to state 49
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 35

    (3) function -> FN ID . ( parameter ) { body }

    (               shift and go to state 51


state 36

    (6) function_call -> ID ( . term_list )
    (22) term_list -> . term_list , term
    (23) term_list -> . term
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    )               reduce using rule 44 (empty -> .)
    ,               reduce using rule 44 (empty -> .)

    term_list                      shift and go to state 52
    term                           shift and go to state 41
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 37

    (4) function -> COMMAND ID . ( parameter ) { body }

    (               shift and go to state 53


state 38

    (5) function -> HANDLER ID . ( parameter ) { body }

    (               shift and go to state 54


state 39

    (24) term -> unop term .

    SIGN            reduce using rule 24 (term -> unop term .)
    BINARY_OPERATOR reduce using rule 24 (term -> unop term .)
    $end            reduce using rule 24 (term -> unop term .)
    {               reduce using rule 24 (term -> unop term .)
    :               reduce using rule 24 (term -> unop term .)
    ]               reduce using rule 24 (term -> unop term .)
    ,               reduce using rule 24 (term -> unop term .)
    }               reduce using rule 24 (term -> unop term .)
    IF              reduce using rule 24 (term -> unop term .)
    TRY             reduce using rule 24 (term -> unop term .)
    ID              reduce using rule 24 (term -> unop term .)
    UNITARY_OPERATOR reduce using rule 24 (term -> unop term .)
    FLOAT           reduce using rule 24 (term -> unop term .)
    INTEGER         reduce using rule 24 (term -> unop term .)
    BOOLEAN         reduce using rule 24 (term -> unop term .)
    STRING          reduce using rule 24 (term -> unop term .)
    [               reduce using rule 24 (term -> unop term .)
    )               reduce using rule 24 (term -> unop term .)


state 40

    (39) list -> [ term_list . ]
    (22) term_list -> term_list . , term

    ]               shift and go to state 55
    ,               shift and go to state 56


state 41

    (23) term_list -> term .

    ]               reduce using rule 23 (term_list -> term .)
    ,               reduce using rule 23 (term_list -> term .)
    )               reduce using rule 23 (term_list -> term .)


state 42

    (14) exp -> term binop exp .

    $end            reduce using rule 14 (exp -> term binop exp .)
    {               reduce using rule 14 (exp -> term binop exp .)
    }               reduce using rule 14 (exp -> term binop exp .)
    IF              reduce using rule 14 (exp -> term binop exp .)
    TRY             reduce using rule 14 (exp -> term binop exp .)
    ID              reduce using rule 14 (exp -> term binop exp .)
    SIGN            reduce using rule 14 (exp -> term binop exp .)
    UNITARY_OPERATOR reduce using rule 14 (exp -> term binop exp .)
    FLOAT           reduce using rule 14 (exp -> term binop exp .)
    INTEGER         reduce using rule 14 (exp -> term binop exp .)
    BOOLEAN         reduce using rule 14 (exp -> term binop exp .)
    STRING          reduce using rule 14 (exp -> term binop exp .)
    [               reduce using rule 14 (exp -> term binop exp .)
    BINARY_OPERATOR reduce using rule 14 (exp -> term binop exp .)


state 43

    (16) exp -> IF exp { . body } ELSE { body }
    (17) exp -> IF exp { . body }
    (10) body -> . body exp
    (11) body -> . body variable
    (12) body -> . exp
    (13) body -> . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 48
    body                           shift and go to state 57
    variable                       shift and go to state 49
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 44

    (37) dict -> { term_map } .

    SIGN            reduce using rule 37 (dict -> { term_map } .)
    BINARY_OPERATOR reduce using rule 37 (dict -> { term_map } .)
    $end            reduce using rule 37 (dict -> { term_map } .)
    {               reduce using rule 37 (dict -> { term_map } .)
    :               reduce using rule 37 (dict -> { term_map } .)
    ]               reduce using rule 37 (dict -> { term_map } .)
    ,               reduce using rule 37 (dict -> { term_map } .)
    }               reduce using rule 37 (dict -> { term_map } .)
    IF              reduce using rule 37 (dict -> { term_map } .)
    TRY             reduce using rule 37 (dict -> { term_map } .)
    ID              reduce using rule 37 (dict -> { term_map } .)
    UNITARY_OPERATOR reduce using rule 37 (dict -> { term_map } .)
    FLOAT           reduce using rule 37 (dict -> { term_map } .)
    INTEGER         reduce using rule 37 (dict -> { term_map } .)
    BOOLEAN         reduce using rule 37 (dict -> { term_map } .)
    STRING          reduce using rule 37 (dict -> { term_map } .)
    [               reduce using rule 37 (dict -> { term_map } .)
    )               reduce using rule 37 (dict -> { term_map } .)


state 45

    (38) dict -> { empty } .

    SIGN            reduce using rule 38 (dict -> { empty } .)
    BINARY_OPERATOR reduce using rule 38 (dict -> { empty } .)
    $end            reduce using rule 38 (dict -> { empty } .)
    {               reduce using rule 38 (dict -> { empty } .)
    :               reduce using rule 38 (dict -> { empty } .)
    ]               reduce using rule 38 (dict -> { empty } .)
    ,               reduce using rule 38 (dict -> { empty } .)
    }               reduce using rule 38 (dict -> { empty } .)
    IF              reduce using rule 38 (dict -> { empty } .)
    TRY             reduce using rule 38 (dict -> { empty } .)
    ID              reduce using rule 38 (dict -> { empty } .)
    UNITARY_OPERATOR reduce using rule 38 (dict -> { empty } .)
    FLOAT           reduce using rule 38 (dict -> { empty } .)
    INTEGER         reduce using rule 38 (dict -> { empty } .)
    BOOLEAN         reduce using rule 38 (dict -> { empty } .)
    STRING          reduce using rule 38 (dict -> { empty } .)
    [               reduce using rule 38 (dict -> { empty } .)
    )               reduce using rule 38 (dict -> { empty } .)


state 46

    (20) term_map -> term : . term , term_map
    (21) term_map -> term : . term
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    ,               reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

    term                           shift and go to state 58
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 47

    (18) exp -> TRY { body . } CATCH { body }
    (10) body -> body . exp
    (11) body -> body . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 59
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! }               [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 60
    variable                       shift and go to state 61
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 48

    (12) body -> exp .

    }               reduce using rule 12 (body -> exp .)
    IF              reduce using rule 12 (body -> exp .)
    TRY             reduce using rule 12 (body -> exp .)
    ID              reduce using rule 12 (body -> exp .)
    SIGN            reduce using rule 12 (body -> exp .)
    UNITARY_OPERATOR reduce using rule 12 (body -> exp .)
    FLOAT           reduce using rule 12 (body -> exp .)
    INTEGER         reduce using rule 12 (body -> exp .)
    BOOLEAN         reduce using rule 12 (body -> exp .)
    STRING          reduce using rule 12 (body -> exp .)
    [               reduce using rule 12 (body -> exp .)
    {               reduce using rule 12 (body -> exp .)
    BINARY_OPERATOR reduce using rule 12 (body -> exp .)


state 49

    (13) body -> variable .

    }               reduce using rule 13 (body -> variable .)
    IF              reduce using rule 13 (body -> variable .)
    TRY             reduce using rule 13 (body -> variable .)
    ID              reduce using rule 13 (body -> variable .)
    SIGN            reduce using rule 13 (body -> variable .)
    UNITARY_OPERATOR reduce using rule 13 (body -> variable .)
    FLOAT           reduce using rule 13 (body -> variable .)
    INTEGER         reduce using rule 13 (body -> variable .)
    BOOLEAN         reduce using rule 13 (body -> variable .)
    STRING          reduce using rule 13 (body -> variable .)
    [               reduce using rule 13 (body -> variable .)
    {               reduce using rule 13 (body -> variable .)
    BINARY_OPERATOR reduce using rule 13 (body -> variable .)


state 50

    (19) variable -> ID . = exp
    (29) term -> ID .
    (6) function_call -> ID . ( term_list )

    =               shift and go to state 62
    SIGN            reduce using rule 29 (term -> ID .)
    BINARY_OPERATOR reduce using rule 29 (term -> ID .)
    }               reduce using rule 29 (term -> ID .)
    IF              reduce using rule 29 (term -> ID .)
    TRY             reduce using rule 29 (term -> ID .)
    ID              reduce using rule 29 (term -> ID .)
    UNITARY_OPERATOR reduce using rule 29 (term -> ID .)
    FLOAT           reduce using rule 29 (term -> ID .)
    INTEGER         reduce using rule 29 (term -> ID .)
    BOOLEAN         reduce using rule 29 (term -> ID .)
    STRING          reduce using rule 29 (term -> ID .)
    [               reduce using rule 29 (term -> ID .)
    {               reduce using rule 29 (term -> ID .)
    (               shift and go to state 36


state 51

    (3) function -> FN ID ( . parameter ) { body }
    (7) parameter -> . ID , parameter
    (8) parameter -> . ID
    (9) parameter -> . empty
    (44) empty -> .

    ID              shift and go to state 63
    )               reduce using rule 44 (empty -> .)

    parameter                      shift and go to state 64
    empty                          shift and go to state 65

state 52

    (6) function_call -> ID ( term_list . )
    (22) term_list -> term_list . , term

    )               shift and go to state 66
    ,               shift and go to state 56


state 53

    (4) function -> COMMAND ID ( . parameter ) { body }
    (7) parameter -> . ID , parameter
    (8) parameter -> . ID
    (9) parameter -> . empty
    (44) empty -> .

    ID              shift and go to state 63
    )               reduce using rule 44 (empty -> .)

    parameter                      shift and go to state 67
    empty                          shift and go to state 65

state 54

    (5) function -> HANDLER ID ( . parameter ) { body }
    (7) parameter -> . ID , parameter
    (8) parameter -> . ID
    (9) parameter -> . empty
    (44) empty -> .

    ID              shift and go to state 63
    )               reduce using rule 44 (empty -> .)

    parameter                      shift and go to state 68
    empty                          shift and go to state 65

state 55

    (39) list -> [ term_list ] .

    SIGN            reduce using rule 39 (list -> [ term_list ] .)
    BINARY_OPERATOR reduce using rule 39 (list -> [ term_list ] .)
    $end            reduce using rule 39 (list -> [ term_list ] .)
    {               reduce using rule 39 (list -> [ term_list ] .)
    :               reduce using rule 39 (list -> [ term_list ] .)
    ]               reduce using rule 39 (list -> [ term_list ] .)
    ,               reduce using rule 39 (list -> [ term_list ] .)
    }               reduce using rule 39 (list -> [ term_list ] .)
    IF              reduce using rule 39 (list -> [ term_list ] .)
    TRY             reduce using rule 39 (list -> [ term_list ] .)
    ID              reduce using rule 39 (list -> [ term_list ] .)
    UNITARY_OPERATOR reduce using rule 39 (list -> [ term_list ] .)
    FLOAT           reduce using rule 39 (list -> [ term_list ] .)
    INTEGER         reduce using rule 39 (list -> [ term_list ] .)
    BOOLEAN         reduce using rule 39 (list -> [ term_list ] .)
    STRING          reduce using rule 39 (list -> [ term_list ] .)
    [               reduce using rule 39 (list -> [ term_list ] .)
    )               reduce using rule 39 (list -> [ term_list ] .)


state 56

    (22) term_list -> term_list , . term
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    ]               reduce using rule 44 (empty -> .)
    ,               reduce using rule 44 (empty -> .)
    )               reduce using rule 44 (empty -> .)

    term                           shift and go to state 69
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 57

    (16) exp -> IF exp { body . } ELSE { body }
    (17) exp -> IF exp { body . }
    (10) body -> body . exp
    (11) body -> body . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 70
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! }               [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 60
    variable                       shift and go to state 61
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 58

    (20) term_map -> term : term . , term_map
    (21) term_map -> term : term .

    ,               shift and go to state 71
    }               reduce using rule 21 (term_map -> term : term .)


state 59

    (18) exp -> TRY { body } . CATCH { body }

    CATCH           shift and go to state 72


state 60

    (10) body -> body exp .

    }               reduce using rule 10 (body -> body exp .)
    IF              reduce using rule 10 (body -> body exp .)
    TRY             reduce using rule 10 (body -> body exp .)
    ID              reduce using rule 10 (body -> body exp .)
    SIGN            reduce using rule 10 (body -> body exp .)
    UNITARY_OPERATOR reduce using rule 10 (body -> body exp .)
    FLOAT           reduce using rule 10 (body -> body exp .)
    INTEGER         reduce using rule 10 (body -> body exp .)
    BOOLEAN         reduce using rule 10 (body -> body exp .)
    STRING          reduce using rule 10 (body -> body exp .)
    [               reduce using rule 10 (body -> body exp .)
    {               reduce using rule 10 (body -> body exp .)
    BINARY_OPERATOR reduce using rule 10 (body -> body exp .)


state 61

    (11) body -> body variable .

    }               reduce using rule 11 (body -> body variable .)
    IF              reduce using rule 11 (body -> body variable .)
    TRY             reduce using rule 11 (body -> body variable .)
    ID              reduce using rule 11 (body -> body variable .)
    SIGN            reduce using rule 11 (body -> body variable .)
    UNITARY_OPERATOR reduce using rule 11 (body -> body variable .)
    FLOAT           reduce using rule 11 (body -> body variable .)
    INTEGER         reduce using rule 11 (body -> body variable .)
    BOOLEAN         reduce using rule 11 (body -> body variable .)
    STRING          reduce using rule 11 (body -> body variable .)
    [               reduce using rule 11 (body -> body variable .)
    {               reduce using rule 11 (body -> body variable .)
    BINARY_OPERATOR reduce using rule 11 (body -> body variable .)


state 62

    (19) variable -> ID = . exp
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 73
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 63

    (7) parameter -> ID . , parameter
    (8) parameter -> ID .

    ,               shift and go to state 74
    )               reduce using rule 8 (parameter -> ID .)


state 64

    (3) function -> FN ID ( parameter . ) { body }

    )               shift and go to state 75


state 65

    (9) parameter -> empty .

    )               reduce using rule 9 (parameter -> empty .)


state 66

    (6) function_call -> ID ( term_list ) .

    SIGN            reduce using rule 6 (function_call -> ID ( term_list ) .)
    BINARY_OPERATOR reduce using rule 6 (function_call -> ID ( term_list ) .)
    $end            reduce using rule 6 (function_call -> ID ( term_list ) .)
    {               reduce using rule 6 (function_call -> ID ( term_list ) .)
    :               reduce using rule 6 (function_call -> ID ( term_list ) .)
    ]               reduce using rule 6 (function_call -> ID ( term_list ) .)
    ,               reduce using rule 6 (function_call -> ID ( term_list ) .)
    }               reduce using rule 6 (function_call -> ID ( term_list ) .)
    IF              reduce using rule 6 (function_call -> ID ( term_list ) .)
    TRY             reduce using rule 6 (function_call -> ID ( term_list ) .)
    ID              reduce using rule 6 (function_call -> ID ( term_list ) .)
    UNITARY_OPERATOR reduce using rule 6 (function_call -> ID ( term_list ) .)
    FLOAT           reduce using rule 6 (function_call -> ID ( term_list ) .)
    INTEGER         reduce using rule 6 (function_call -> ID ( term_list ) .)
    BOOLEAN         reduce using rule 6 (function_call -> ID ( term_list ) .)
    STRING          reduce using rule 6 (function_call -> ID ( term_list ) .)
    [               reduce using rule 6 (function_call -> ID ( term_list ) .)
    )               reduce using rule 6 (function_call -> ID ( term_list ) .)


state 67

    (4) function -> COMMAND ID ( parameter . ) { body }

    )               shift and go to state 76


state 68

    (5) function -> HANDLER ID ( parameter . ) { body }

    )               shift and go to state 77


state 69

    (22) term_list -> term_list , term .

    ]               reduce using rule 22 (term_list -> term_list , term .)
    ,               reduce using rule 22 (term_list -> term_list , term .)
    )               reduce using rule 22 (term_list -> term_list , term .)


state 70

    (16) exp -> IF exp { body } . ELSE { body }
    (17) exp -> IF exp { body } .

    ELSE            shift and go to state 78
    $end            reduce using rule 17 (exp -> IF exp { body } .)
    {               reduce using rule 17 (exp -> IF exp { body } .)
    }               reduce using rule 17 (exp -> IF exp { body } .)
    IF              reduce using rule 17 (exp -> IF exp { body } .)
    TRY             reduce using rule 17 (exp -> IF exp { body } .)
    ID              reduce using rule 17 (exp -> IF exp { body } .)
    SIGN            reduce using rule 17 (exp -> IF exp { body } .)
    UNITARY_OPERATOR reduce using rule 17 (exp -> IF exp { body } .)
    FLOAT           reduce using rule 17 (exp -> IF exp { body } .)
    INTEGER         reduce using rule 17 (exp -> IF exp { body } .)
    BOOLEAN         reduce using rule 17 (exp -> IF exp { body } .)
    STRING          reduce using rule 17 (exp -> IF exp { body } .)
    [               reduce using rule 17 (exp -> IF exp { body } .)
    BINARY_OPERATOR reduce using rule 17 (exp -> IF exp { body } .)


state 71

    (20) term_map -> term : term , . term_map
    (20) term_map -> . term : term , term_map
    (21) term_map -> . term : term
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

    ID              shift and go to state 9
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    :               reduce using rule 44 (empty -> .)

    term                           shift and go to state 33
    term_map                       shift and go to state 79
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 72

    (18) exp -> TRY { body } CATCH . { body }

    {               shift and go to state 80


state 73

    (19) variable -> ID = exp .

    }               reduce using rule 19 (variable -> ID = exp .)
    IF              reduce using rule 19 (variable -> ID = exp .)
    TRY             reduce using rule 19 (variable -> ID = exp .)
    ID              reduce using rule 19 (variable -> ID = exp .)
    SIGN            reduce using rule 19 (variable -> ID = exp .)
    UNITARY_OPERATOR reduce using rule 19 (variable -> ID = exp .)
    FLOAT           reduce using rule 19 (variable -> ID = exp .)
    INTEGER         reduce using rule 19 (variable -> ID = exp .)
    BOOLEAN         reduce using rule 19 (variable -> ID = exp .)
    STRING          reduce using rule 19 (variable -> ID = exp .)
    [               reduce using rule 19 (variable -> ID = exp .)
    {               reduce using rule 19 (variable -> ID = exp .)
    BINARY_OPERATOR reduce using rule 19 (variable -> ID = exp .)


state 74

    (7) parameter -> ID , . parameter
    (7) parameter -> . ID , parameter
    (8) parameter -> . ID
    (9) parameter -> . empty
    (44) empty -> .

    ID              shift and go to state 63
    )               reduce using rule 44 (empty -> .)

    parameter                      shift and go to state 81
    empty                          shift and go to state 65

state 75

    (3) function -> FN ID ( parameter ) . { body }

    {               shift and go to state 82


state 76

    (4) function -> COMMAND ID ( parameter ) . { body }

    {               shift and go to state 83


state 77

    (5) function -> HANDLER ID ( parameter ) . { body }

    {               shift and go to state 84


state 78

    (16) exp -> IF exp { body } ELSE . { body }

    {               shift and go to state 85


state 79

    (20) term_map -> term : term , term_map .

    }               reduce using rule 20 (term_map -> term : term , term_map .)


state 80

    (18) exp -> TRY { body } CATCH { . body }
    (10) body -> . body exp
    (11) body -> . body variable
    (12) body -> . exp
    (13) body -> . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    body                           shift and go to state 86
    exp                            shift and go to state 48
    variable                       shift and go to state 49
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 81

    (7) parameter -> ID , parameter .

    )               reduce using rule 7 (parameter -> ID , parameter .)


state 82

    (3) function -> FN ID ( parameter ) { . body }
    (10) body -> . body exp
    (11) body -> . body variable
    (12) body -> . exp
    (13) body -> . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    body                           shift and go to state 87
    exp                            shift and go to state 48
    variable                       shift and go to state 49
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 83

    (4) function -> COMMAND ID ( parameter ) { . body }
    (10) body -> . body exp
    (11) body -> . body variable
    (12) body -> . exp
    (13) body -> . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    body                           shift and go to state 88
    exp                            shift and go to state 48
    variable                       shift and go to state 49
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 84

    (5) function -> HANDLER ID ( parameter ) { . body }
    (10) body -> . body exp
    (11) body -> . body variable
    (12) body -> . exp
    (13) body -> . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    body                           shift and go to state 89
    exp                            shift and go to state 48
    variable                       shift and go to state 49
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 85

    (16) exp -> IF exp { body } ELSE { . body }
    (10) body -> . body exp
    (11) body -> . body variable
    (12) body -> . exp
    (13) body -> . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)
    }               reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 48
    body                           shift and go to state 90
    variable                       shift and go to state 49
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 86

    (18) exp -> TRY { body } CATCH { body . }
    (10) body -> body . exp
    (11) body -> body . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 91
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! }               [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 60
    variable                       shift and go to state 61
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 87

    (3) function -> FN ID ( parameter ) { body . }
    (10) body -> body . exp
    (11) body -> body . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 92
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! }               [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 60
    variable                       shift and go to state 61
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 88

    (4) function -> COMMAND ID ( parameter ) { body . }
    (10) body -> body . exp
    (11) body -> body . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 93
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! }               [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 60
    variable                       shift and go to state 61
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 89

    (5) function -> HANDLER ID ( parameter ) { body . }
    (10) body -> body . exp
    (11) body -> body . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 94
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! }               [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 60
    variable                       shift and go to state 61
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 90

    (16) exp -> IF exp { body } ELSE { body . }
    (10) body -> body . exp
    (11) body -> body . variable
    (14) exp -> . term binop exp
    (15) exp -> . term
    (16) exp -> . IF exp { body } ELSE { body }
    (17) exp -> . IF exp { body }
    (18) exp -> . TRY { body } CATCH { body }
    (19) variable -> . ID = exp
    (24) term -> . unop term
    (25) term -> . number
    (26) term -> . boolean
    (27) term -> . string
    (28) term -> . function_call
    (29) term -> . ID
    (30) term -> . list
    (31) term -> . dict
    (32) term -> . empty
    (33) unop -> . SIGN
    (34) unop -> . UNITARY_OPERATOR
    (40) number -> . FLOAT
    (41) number -> . INTEGER
    (42) boolean -> . BOOLEAN
    (43) string -> . STRING
    (6) function_call -> . ID ( term_list )
    (39) list -> . [ term_list ]
    (37) dict -> . { term_map }
    (38) dict -> . { empty }
    (44) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 95
    IF              shift and go to state 5
    TRY             shift and go to state 7
    ID              shift and go to state 50
    SIGN            shift and go to state 20
    UNITARY_OPERATOR shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    BOOLEAN         shift and go to state 24
    STRING          shift and go to state 25
    [               shift and go to state 26
    {               shift and go to state 6
    BINARY_OPERATOR reduce using rule 44 (empty -> .)

  ! SIGN            [ reduce using rule 44 (empty -> .) ]
  ! }               [ reduce using rule 44 (empty -> .) ]
  ! IF              [ reduce using rule 44 (empty -> .) ]
  ! TRY             [ reduce using rule 44 (empty -> .) ]
  ! ID              [ reduce using rule 44 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 44 (empty -> .) ]
  ! FLOAT           [ reduce using rule 44 (empty -> .) ]
  ! INTEGER         [ reduce using rule 44 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 44 (empty -> .) ]
  ! STRING          [ reduce using rule 44 (empty -> .) ]
  ! [               [ reduce using rule 44 (empty -> .) ]
  ! {               [ reduce using rule 44 (empty -> .) ]

    exp                            shift and go to state 60
    variable                       shift and go to state 61
    term                           shift and go to state 4
    unop                           shift and go to state 12
    number                         shift and go to state 13
    boolean                        shift and go to state 14
    string                         shift and go to state 15
    function_call                  shift and go to state 16
    list                           shift and go to state 17
    dict                           shift and go to state 18
    empty                          shift and go to state 19

state 91

    (18) exp -> TRY { body } CATCH { body } .

    $end            reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    {               reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    }               reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    IF              reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    TRY             reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    ID              reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    SIGN            reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    UNITARY_OPERATOR reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    FLOAT           reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    INTEGER         reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    BOOLEAN         reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    STRING          reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    [               reduce using rule 18 (exp -> TRY { body } CATCH { body } .)
    BINARY_OPERATOR reduce using rule 18 (exp -> TRY { body } CATCH { body } .)


state 92

    (3) function -> FN ID ( parameter ) { body } .

    $end            reduce using rule 3 (function -> FN ID ( parameter ) { body } .)


state 93

    (4) function -> COMMAND ID ( parameter ) { body } .

    $end            reduce using rule 4 (function -> COMMAND ID ( parameter ) { body } .)


state 94

    (5) function -> HANDLER ID ( parameter ) { body } .

    $end            reduce using rule 5 (function -> HANDLER ID ( parameter ) { body } .)


state 95

    (16) exp -> IF exp { body } ELSE { body } .

    $end            reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    {               reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    }               reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    IF              reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    TRY             reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    ID              reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    SIGN            reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    UNITARY_OPERATOR reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    FLOAT           reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    INTEGER         reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    BOOLEAN         reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    STRING          reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    [               reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)
    BINARY_OPERATOR reduce using rule 16 (exp -> IF exp { body } ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SIGN in state 0 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 4 resolved as shift
WARNING: shift/reduce conflict for BINARY_OPERATOR in state 4 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 5 resolved as shift
WARNING: shift/reduce conflict for { in state 5 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 12 resolved as shift
WARNING: shift/reduce conflict for { in state 12 resolved as shift
WARNING: shift/reduce conflict for ID in state 12 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 12 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 12 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 12 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 12 resolved as shift
WARNING: shift/reduce conflict for STRING in state 12 resolved as shift
WARNING: shift/reduce conflict for [ in state 12 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 27 resolved as shift
WARNING: shift/reduce conflict for { in state 27 resolved as shift
WARNING: shift/reduce conflict for IF in state 27 resolved as shift
WARNING: shift/reduce conflict for TRY in state 27 resolved as shift
WARNING: shift/reduce conflict for ID in state 27 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 27 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 27 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 27 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 27 resolved as shift
WARNING: shift/reduce conflict for STRING in state 27 resolved as shift
WARNING: shift/reduce conflict for [ in state 27 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 34 resolved as shift
WARNING: shift/reduce conflict for IF in state 34 resolved as shift
WARNING: shift/reduce conflict for TRY in state 34 resolved as shift
WARNING: shift/reduce conflict for ID in state 34 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 34 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 34 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 34 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 34 resolved as shift
WARNING: shift/reduce conflict for STRING in state 34 resolved as shift
WARNING: shift/reduce conflict for [ in state 34 resolved as shift
WARNING: shift/reduce conflict for { in state 34 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 43 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for TRY in state 43 resolved as shift
WARNING: shift/reduce conflict for ID in state 43 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 43 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 43 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 43 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 43 resolved as shift
WARNING: shift/reduce conflict for STRING in state 43 resolved as shift
WARNING: shift/reduce conflict for [ in state 43 resolved as shift
WARNING: shift/reduce conflict for { in state 43 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 47 resolved as shift
WARNING: shift/reduce conflict for } in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for TRY in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 47 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 47 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 47 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 47 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 47 resolved as shift
WARNING: shift/reduce conflict for STRING in state 47 resolved as shift
WARNING: shift/reduce conflict for [ in state 47 resolved as shift
WARNING: shift/reduce conflict for { in state 47 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 57 resolved as shift
WARNING: shift/reduce conflict for } in state 57 resolved as shift
WARNING: shift/reduce conflict for IF in state 57 resolved as shift
WARNING: shift/reduce conflict for TRY in state 57 resolved as shift
WARNING: shift/reduce conflict for ID in state 57 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 57 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 57 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 57 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 57 resolved as shift
WARNING: shift/reduce conflict for STRING in state 57 resolved as shift
WARNING: shift/reduce conflict for [ in state 57 resolved as shift
WARNING: shift/reduce conflict for { in state 57 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 62 resolved as shift
WARNING: shift/reduce conflict for IF in state 62 resolved as shift
WARNING: shift/reduce conflict for TRY in state 62 resolved as shift
WARNING: shift/reduce conflict for ID in state 62 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 62 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 62 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 62 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 62 resolved as shift
WARNING: shift/reduce conflict for STRING in state 62 resolved as shift
WARNING: shift/reduce conflict for [ in state 62 resolved as shift
WARNING: shift/reduce conflict for { in state 62 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 80 resolved as shift
WARNING: shift/reduce conflict for IF in state 80 resolved as shift
WARNING: shift/reduce conflict for TRY in state 80 resolved as shift
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 80 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 80 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 80 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 80 resolved as shift
WARNING: shift/reduce conflict for STRING in state 80 resolved as shift
WARNING: shift/reduce conflict for [ in state 80 resolved as shift
WARNING: shift/reduce conflict for { in state 80 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 82 resolved as shift
WARNING: shift/reduce conflict for IF in state 82 resolved as shift
WARNING: shift/reduce conflict for TRY in state 82 resolved as shift
WARNING: shift/reduce conflict for ID in state 82 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 82 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 82 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 82 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 82 resolved as shift
WARNING: shift/reduce conflict for STRING in state 82 resolved as shift
WARNING: shift/reduce conflict for [ in state 82 resolved as shift
WARNING: shift/reduce conflict for { in state 82 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 83 resolved as shift
WARNING: shift/reduce conflict for IF in state 83 resolved as shift
WARNING: shift/reduce conflict for TRY in state 83 resolved as shift
WARNING: shift/reduce conflict for ID in state 83 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 83 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 83 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 83 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 83 resolved as shift
WARNING: shift/reduce conflict for STRING in state 83 resolved as shift
WARNING: shift/reduce conflict for [ in state 83 resolved as shift
WARNING: shift/reduce conflict for { in state 83 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 84 resolved as shift
WARNING: shift/reduce conflict for IF in state 84 resolved as shift
WARNING: shift/reduce conflict for TRY in state 84 resolved as shift
WARNING: shift/reduce conflict for ID in state 84 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 84 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 84 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 84 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 84 resolved as shift
WARNING: shift/reduce conflict for STRING in state 84 resolved as shift
WARNING: shift/reduce conflict for [ in state 84 resolved as shift
WARNING: shift/reduce conflict for { in state 84 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 85 resolved as shift
WARNING: shift/reduce conflict for IF in state 85 resolved as shift
WARNING: shift/reduce conflict for TRY in state 85 resolved as shift
WARNING: shift/reduce conflict for ID in state 85 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 85 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 85 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 85 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 85 resolved as shift
WARNING: shift/reduce conflict for STRING in state 85 resolved as shift
WARNING: shift/reduce conflict for [ in state 85 resolved as shift
WARNING: shift/reduce conflict for { in state 85 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 86 resolved as shift
WARNING: shift/reduce conflict for } in state 86 resolved as shift
WARNING: shift/reduce conflict for IF in state 86 resolved as shift
WARNING: shift/reduce conflict for TRY in state 86 resolved as shift
WARNING: shift/reduce conflict for ID in state 86 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 86 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 86 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 86 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 86 resolved as shift
WARNING: shift/reduce conflict for STRING in state 86 resolved as shift
WARNING: shift/reduce conflict for [ in state 86 resolved as shift
WARNING: shift/reduce conflict for { in state 86 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 87 resolved as shift
WARNING: shift/reduce conflict for } in state 87 resolved as shift
WARNING: shift/reduce conflict for IF in state 87 resolved as shift
WARNING: shift/reduce conflict for TRY in state 87 resolved as shift
WARNING: shift/reduce conflict for ID in state 87 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 87 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 87 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 87 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 87 resolved as shift
WARNING: shift/reduce conflict for STRING in state 87 resolved as shift
WARNING: shift/reduce conflict for [ in state 87 resolved as shift
WARNING: shift/reduce conflict for { in state 87 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 88 resolved as shift
WARNING: shift/reduce conflict for } in state 88 resolved as shift
WARNING: shift/reduce conflict for IF in state 88 resolved as shift
WARNING: shift/reduce conflict for TRY in state 88 resolved as shift
WARNING: shift/reduce conflict for ID in state 88 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 88 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 88 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 88 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 88 resolved as shift
WARNING: shift/reduce conflict for STRING in state 88 resolved as shift
WARNING: shift/reduce conflict for [ in state 88 resolved as shift
WARNING: shift/reduce conflict for { in state 88 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 89 resolved as shift
WARNING: shift/reduce conflict for } in state 89 resolved as shift
WARNING: shift/reduce conflict for IF in state 89 resolved as shift
WARNING: shift/reduce conflict for TRY in state 89 resolved as shift
WARNING: shift/reduce conflict for ID in state 89 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 89 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 89 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 89 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 89 resolved as shift
WARNING: shift/reduce conflict for STRING in state 89 resolved as shift
WARNING: shift/reduce conflict for [ in state 89 resolved as shift
WARNING: shift/reduce conflict for { in state 89 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 90 resolved as shift
WARNING: shift/reduce conflict for } in state 90 resolved as shift
WARNING: shift/reduce conflict for IF in state 90 resolved as shift
WARNING: shift/reduce conflict for TRY in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 90 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 90 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 90 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 90 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 90 resolved as shift
WARNING: shift/reduce conflict for STRING in state 90 resolved as shift
WARNING: shift/reduce conflict for [ in state 90 resolved as shift
WARNING: shift/reduce conflict for { in state 90 resolved as shift
