Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> run
Rule 1     run -> program
Rule 2     program -> program function
Rule 3     program -> program function_call
Rule 4     program -> program variable
Rule 5     program -> program token
Rule 6     program -> function
Rule 7     program -> function_call
Rule 8     program -> variable
Rule 9     program -> token
Rule 10    function -> FN id ( parameter ) { body }
Rule 11    function -> COMMAND id ( parameter ) { body }
Rule 12    token -> TOKEN ( string )
Rule 13    function_call -> id ( term_list )
Rule 14    parameter -> id , parameter
Rule 15    parameter -> id
Rule 16    parameter -> empty
Rule 17    body -> body exp
Rule 18    body -> body variable
Rule 19    body -> body return
Rule 20    body -> body global
Rule 21    body -> exp
Rule 22    body -> variable
Rule 23    body -> return
Rule 24    body -> global
Rule 25    exp -> term binop exp
Rule 26    exp -> term
Rule 27    exp -> IF exp { body } ELSE { body }
Rule 28    exp -> IF exp { body }
Rule 29    exp -> TRY { body } CATCH { body }
Rule 30    variable -> id = exp
Rule 31    return -> RET id
Rule 32    global -> GLOBAL term_list
Rule 33    term_map -> term : term , term_map
Rule 34    term_map -> term : term
Rule 35    term_list -> term_list , term
Rule 36    term_list -> term
Rule 37    term -> unop term
Rule 38    term -> number
Rule 39    term -> boolean
Rule 40    term -> string
Rule 41    term -> function_call
Rule 42    term -> id
Rule 43    term -> list
Rule 44    term -> dict
Rule 45    term -> empty
Rule 46    unop -> SIGN
Rule 47    unop -> UNITARY_OPERATOR
Rule 48    binop -> SIGN
Rule 49    binop -> BINARY_OPERATOR
Rule 50    dict -> { term_map }
Rule 51    dict -> { empty }
Rule 52    list -> [ term_list ]
Rule 53    number -> FLOAT
Rule 54    number -> INTEGER
Rule 55    boolean -> BOOLEAN
Rule 56    string -> STRING
Rule 57    id -> ID
Rule 58    empty -> <empty>

Terminals, with rules where they appear

(                    : 10 11 12 13
)                    : 10 11 12 13
,                    : 14 33 35
:                    : 33 34
=                    : 30
BINARY_OPERATOR      : 49
BOOLEAN              : 55
CATCH                : 29
COMMAND              : 11
ELSE                 : 27
FLOAT                : 53
FN                   : 10
GLOBAL               : 32
ID                   : 57
IF                   : 27 28
INTEGER              : 54
RET                  : 31
SIGN                 : 46 48
STRING               : 56
TOKEN                : 12
TRY                  : 29
UNITARY_OPERATOR     : 47
[                    : 52
]                    : 52
error                : 
{                    : 10 11 27 27 28 29 29 50 51
}                    : 10 11 27 27 28 29 29 50 51

Nonterminals, with rules where they appear

binop                : 25
body                 : 10 11 17 18 19 20 27 27 28 29 29
boolean              : 39
dict                 : 44
empty                : 16 45 51
exp                  : 17 21 25 27 28 30
function             : 2 6
function_call        : 3 7 41
global               : 20 24
id                   : 10 11 13 14 15 30 31 42
list                 : 43
number               : 38
parameter            : 10 11 14
program              : 1 2 3 4 5
return               : 19 23
run                  : 0
string               : 12 40
term                 : 25 26 33 33 34 34 35 36 37
term_list            : 13 32 35 52
term_map             : 33 50
token                : 5 9
unop                 : 37
variable             : 4 8 18 22

Parsing method: LALR

state 0

    (0) S' -> . run
    (1) run -> . program
    (2) program -> . program function
    (3) program -> . program function_call
    (4) program -> . program variable
    (5) program -> . program token
    (6) program -> . function
    (7) program -> . function_call
    (8) program -> . variable
    (9) program -> . token
    (10) function -> . FN id ( parameter ) { body }
    (11) function -> . COMMAND id ( parameter ) { body }
    (13) function_call -> . id ( term_list )
    (30) variable -> . id = exp
    (12) token -> . TOKEN ( string )
    (57) id -> . ID

    FN              shift and go to state 7
    COMMAND         shift and go to state 9
    TOKEN           shift and go to state 10
    ID              shift and go to state 11

    run                            shift and go to state 1
    program                        shift and go to state 2
    function                       shift and go to state 3
    function_call                  shift and go to state 4
    variable                       shift and go to state 5
    token                          shift and go to state 6
    id                             shift and go to state 8

state 1

    (0) S' -> run .



state 2

    (1) run -> program .
    (2) program -> program . function
    (3) program -> program . function_call
    (4) program -> program . variable
    (5) program -> program . token
    (10) function -> . FN id ( parameter ) { body }
    (11) function -> . COMMAND id ( parameter ) { body }
    (13) function_call -> . id ( term_list )
    (30) variable -> . id = exp
    (12) token -> . TOKEN ( string )
    (57) id -> . ID

    $end            reduce using rule 1 (run -> program .)
    FN              shift and go to state 7
    COMMAND         shift and go to state 9
    TOKEN           shift and go to state 10
    ID              shift and go to state 11

    function                       shift and go to state 12
    function_call                  shift and go to state 13
    variable                       shift and go to state 14
    token                          shift and go to state 15
    id                             shift and go to state 8

state 3

    (6) program -> function .

    FN              reduce using rule 6 (program -> function .)
    COMMAND         reduce using rule 6 (program -> function .)
    TOKEN           reduce using rule 6 (program -> function .)
    ID              reduce using rule 6 (program -> function .)
    $end            reduce using rule 6 (program -> function .)


state 4

    (7) program -> function_call .

    FN              reduce using rule 7 (program -> function_call .)
    COMMAND         reduce using rule 7 (program -> function_call .)
    TOKEN           reduce using rule 7 (program -> function_call .)
    ID              reduce using rule 7 (program -> function_call .)
    $end            reduce using rule 7 (program -> function_call .)


state 5

    (8) program -> variable .

    FN              reduce using rule 8 (program -> variable .)
    COMMAND         reduce using rule 8 (program -> variable .)
    TOKEN           reduce using rule 8 (program -> variable .)
    ID              reduce using rule 8 (program -> variable .)
    $end            reduce using rule 8 (program -> variable .)


state 6

    (9) program -> token .

    FN              reduce using rule 9 (program -> token .)
    COMMAND         reduce using rule 9 (program -> token .)
    TOKEN           reduce using rule 9 (program -> token .)
    ID              reduce using rule 9 (program -> token .)
    $end            reduce using rule 9 (program -> token .)


state 7

    (10) function -> FN . id ( parameter ) { body }
    (57) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 16

state 8

    (13) function_call -> id . ( term_list )
    (30) variable -> id . = exp

    (               shift and go to state 17
    =               shift and go to state 18


state 9

    (11) function -> COMMAND . id ( parameter ) { body }
    (57) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 19

state 10

    (12) token -> TOKEN . ( string )

    (               shift and go to state 20


state 11

    (57) id -> ID .

    (               reduce using rule 57 (id -> ID .)
    =               reduce using rule 57 (id -> ID .)
    )               reduce using rule 57 (id -> ID .)
    ,               reduce using rule 57 (id -> ID .)
    SIGN            reduce using rule 57 (id -> ID .)
    BINARY_OPERATOR reduce using rule 57 (id -> ID .)
    FN              reduce using rule 57 (id -> ID .)
    COMMAND         reduce using rule 57 (id -> ID .)
    TOKEN           reduce using rule 57 (id -> ID .)
    ID              reduce using rule 57 (id -> ID .)
    $end            reduce using rule 57 (id -> ID .)
    }               reduce using rule 57 (id -> ID .)
    IF              reduce using rule 57 (id -> ID .)
    TRY             reduce using rule 57 (id -> ID .)
    RET             reduce using rule 57 (id -> ID .)
    GLOBAL          reduce using rule 57 (id -> ID .)
    UNITARY_OPERATOR reduce using rule 57 (id -> ID .)
    FLOAT           reduce using rule 57 (id -> ID .)
    INTEGER         reduce using rule 57 (id -> ID .)
    BOOLEAN         reduce using rule 57 (id -> ID .)
    STRING          reduce using rule 57 (id -> ID .)
    [               reduce using rule 57 (id -> ID .)
    {               reduce using rule 57 (id -> ID .)
    ]               reduce using rule 57 (id -> ID .)
    :               reduce using rule 57 (id -> ID .)


state 12

    (2) program -> program function .

    FN              reduce using rule 2 (program -> program function .)
    COMMAND         reduce using rule 2 (program -> program function .)
    TOKEN           reduce using rule 2 (program -> program function .)
    ID              reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 13

    (3) program -> program function_call .

    FN              reduce using rule 3 (program -> program function_call .)
    COMMAND         reduce using rule 3 (program -> program function_call .)
    TOKEN           reduce using rule 3 (program -> program function_call .)
    ID              reduce using rule 3 (program -> program function_call .)
    $end            reduce using rule 3 (program -> program function_call .)


state 14

    (4) program -> program variable .

    FN              reduce using rule 4 (program -> program variable .)
    COMMAND         reduce using rule 4 (program -> program variable .)
    TOKEN           reduce using rule 4 (program -> program variable .)
    ID              reduce using rule 4 (program -> program variable .)
    $end            reduce using rule 4 (program -> program variable .)


state 15

    (5) program -> program token .

    FN              reduce using rule 5 (program -> program token .)
    COMMAND         reduce using rule 5 (program -> program token .)
    TOKEN           reduce using rule 5 (program -> program token .)
    ID              reduce using rule 5 (program -> program token .)
    $end            reduce using rule 5 (program -> program token .)


state 16

    (10) function -> FN id . ( parameter ) { body }

    (               shift and go to state 21


state 17

    (13) function_call -> id ( . term_list )
    (35) term_list -> . term_list , term
    (36) term_list -> . term
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    )               reduce using rule 58 (empty -> .)
    ,               reduce using rule 58 (empty -> .)

    id                             shift and go to state 22
    term_list                      shift and go to state 23
    term                           shift and go to state 24
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 18

    (30) variable -> id = . exp
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    FN              reduce using rule 58 (empty -> .)
    COMMAND         reduce using rule 58 (empty -> .)
    TOKEN           reduce using rule 58 (empty -> .)
    $end            reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)
    RET             reduce using rule 58 (empty -> .)
    GLOBAL          reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    id                             shift and go to state 22
    exp                            shift and go to state 41
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 19

    (11) function -> COMMAND id . ( parameter ) { body }

    (               shift and go to state 45


state 20

    (12) token -> TOKEN ( . string )
    (56) string -> . STRING

    STRING          shift and go to state 38

    string                         shift and go to state 46

state 21

    (10) function -> FN id ( . parameter ) { body }
    (14) parameter -> . id , parameter
    (15) parameter -> . id
    (16) parameter -> . empty
    (57) id -> . ID
    (58) empty -> .

    ID              shift and go to state 11
    )               reduce using rule 58 (empty -> .)

    id                             shift and go to state 47
    parameter                      shift and go to state 48
    empty                          shift and go to state 49

state 22

    (42) term -> id .
    (13) function_call -> id . ( term_list )

    )               reduce using rule 42 (term -> id .)
    ,               reduce using rule 42 (term -> id .)
    SIGN            reduce using rule 42 (term -> id .)
    BINARY_OPERATOR reduce using rule 42 (term -> id .)
    FN              reduce using rule 42 (term -> id .)
    COMMAND         reduce using rule 42 (term -> id .)
    TOKEN           reduce using rule 42 (term -> id .)
    ID              reduce using rule 42 (term -> id .)
    $end            reduce using rule 42 (term -> id .)
    }               reduce using rule 42 (term -> id .)
    IF              reduce using rule 42 (term -> id .)
    TRY             reduce using rule 42 (term -> id .)
    RET             reduce using rule 42 (term -> id .)
    GLOBAL          reduce using rule 42 (term -> id .)
    UNITARY_OPERATOR reduce using rule 42 (term -> id .)
    FLOAT           reduce using rule 42 (term -> id .)
    INTEGER         reduce using rule 42 (term -> id .)
    BOOLEAN         reduce using rule 42 (term -> id .)
    STRING          reduce using rule 42 (term -> id .)
    [               reduce using rule 42 (term -> id .)
    {               reduce using rule 42 (term -> id .)
    ]               reduce using rule 42 (term -> id .)
    :               reduce using rule 42 (term -> id .)
    (               shift and go to state 17


state 23

    (13) function_call -> id ( term_list . )
    (35) term_list -> term_list . , term

    )               shift and go to state 50
    ,               shift and go to state 51


state 24

    (36) term_list -> term .

    )               reduce using rule 36 (term_list -> term .)
    ,               reduce using rule 36 (term_list -> term .)
    ]               reduce using rule 36 (term_list -> term .)
    }               reduce using rule 36 (term_list -> term .)
    IF              reduce using rule 36 (term_list -> term .)
    TRY             reduce using rule 36 (term_list -> term .)
    RET             reduce using rule 36 (term_list -> term .)
    GLOBAL          reduce using rule 36 (term_list -> term .)
    ID              reduce using rule 36 (term_list -> term .)
    SIGN            reduce using rule 36 (term_list -> term .)
    UNITARY_OPERATOR reduce using rule 36 (term_list -> term .)
    FLOAT           reduce using rule 36 (term_list -> term .)
    INTEGER         reduce using rule 36 (term_list -> term .)
    BOOLEAN         reduce using rule 36 (term_list -> term .)
    STRING          reduce using rule 36 (term_list -> term .)
    [               reduce using rule 36 (term_list -> term .)
    {               reduce using rule 36 (term_list -> term .)
    BINARY_OPERATOR reduce using rule 36 (term_list -> term .)


state 25

    (37) term -> unop . term
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    )               reduce using rule 58 (empty -> .)
    ,               reduce using rule 58 (empty -> .)
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    FN              reduce using rule 58 (empty -> .)
    COMMAND         reduce using rule 58 (empty -> .)
    TOKEN           reduce using rule 58 (empty -> .)
    $end            reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)
    IF              reduce using rule 58 (empty -> .)
    TRY             reduce using rule 58 (empty -> .)
    RET             reduce using rule 58 (empty -> .)
    GLOBAL          reduce using rule 58 (empty -> .)
    ]               reduce using rule 58 (empty -> .)
    :               reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    unop                           shift and go to state 25
    term                           shift and go to state 52
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 26

    (38) term -> number .

    )               reduce using rule 38 (term -> number .)
    ,               reduce using rule 38 (term -> number .)
    SIGN            reduce using rule 38 (term -> number .)
    BINARY_OPERATOR reduce using rule 38 (term -> number .)
    FN              reduce using rule 38 (term -> number .)
    COMMAND         reduce using rule 38 (term -> number .)
    TOKEN           reduce using rule 38 (term -> number .)
    ID              reduce using rule 38 (term -> number .)
    $end            reduce using rule 38 (term -> number .)
    }               reduce using rule 38 (term -> number .)
    IF              reduce using rule 38 (term -> number .)
    TRY             reduce using rule 38 (term -> number .)
    RET             reduce using rule 38 (term -> number .)
    GLOBAL          reduce using rule 38 (term -> number .)
    UNITARY_OPERATOR reduce using rule 38 (term -> number .)
    FLOAT           reduce using rule 38 (term -> number .)
    INTEGER         reduce using rule 38 (term -> number .)
    BOOLEAN         reduce using rule 38 (term -> number .)
    STRING          reduce using rule 38 (term -> number .)
    [               reduce using rule 38 (term -> number .)
    {               reduce using rule 38 (term -> number .)
    ]               reduce using rule 38 (term -> number .)
    :               reduce using rule 38 (term -> number .)


state 27

    (39) term -> boolean .

    )               reduce using rule 39 (term -> boolean .)
    ,               reduce using rule 39 (term -> boolean .)
    SIGN            reduce using rule 39 (term -> boolean .)
    BINARY_OPERATOR reduce using rule 39 (term -> boolean .)
    FN              reduce using rule 39 (term -> boolean .)
    COMMAND         reduce using rule 39 (term -> boolean .)
    TOKEN           reduce using rule 39 (term -> boolean .)
    ID              reduce using rule 39 (term -> boolean .)
    $end            reduce using rule 39 (term -> boolean .)
    }               reduce using rule 39 (term -> boolean .)
    IF              reduce using rule 39 (term -> boolean .)
    TRY             reduce using rule 39 (term -> boolean .)
    RET             reduce using rule 39 (term -> boolean .)
    GLOBAL          reduce using rule 39 (term -> boolean .)
    UNITARY_OPERATOR reduce using rule 39 (term -> boolean .)
    FLOAT           reduce using rule 39 (term -> boolean .)
    INTEGER         reduce using rule 39 (term -> boolean .)
    BOOLEAN         reduce using rule 39 (term -> boolean .)
    STRING          reduce using rule 39 (term -> boolean .)
    [               reduce using rule 39 (term -> boolean .)
    {               reduce using rule 39 (term -> boolean .)
    ]               reduce using rule 39 (term -> boolean .)
    :               reduce using rule 39 (term -> boolean .)


state 28

    (40) term -> string .

    )               reduce using rule 40 (term -> string .)
    ,               reduce using rule 40 (term -> string .)
    SIGN            reduce using rule 40 (term -> string .)
    BINARY_OPERATOR reduce using rule 40 (term -> string .)
    FN              reduce using rule 40 (term -> string .)
    COMMAND         reduce using rule 40 (term -> string .)
    TOKEN           reduce using rule 40 (term -> string .)
    ID              reduce using rule 40 (term -> string .)
    $end            reduce using rule 40 (term -> string .)
    }               reduce using rule 40 (term -> string .)
    IF              reduce using rule 40 (term -> string .)
    TRY             reduce using rule 40 (term -> string .)
    RET             reduce using rule 40 (term -> string .)
    GLOBAL          reduce using rule 40 (term -> string .)
    UNITARY_OPERATOR reduce using rule 40 (term -> string .)
    FLOAT           reduce using rule 40 (term -> string .)
    INTEGER         reduce using rule 40 (term -> string .)
    BOOLEAN         reduce using rule 40 (term -> string .)
    STRING          reduce using rule 40 (term -> string .)
    [               reduce using rule 40 (term -> string .)
    {               reduce using rule 40 (term -> string .)
    ]               reduce using rule 40 (term -> string .)
    :               reduce using rule 40 (term -> string .)


state 29

    (41) term -> function_call .

    )               reduce using rule 41 (term -> function_call .)
    ,               reduce using rule 41 (term -> function_call .)
    SIGN            reduce using rule 41 (term -> function_call .)
    BINARY_OPERATOR reduce using rule 41 (term -> function_call .)
    FN              reduce using rule 41 (term -> function_call .)
    COMMAND         reduce using rule 41 (term -> function_call .)
    TOKEN           reduce using rule 41 (term -> function_call .)
    ID              reduce using rule 41 (term -> function_call .)
    $end            reduce using rule 41 (term -> function_call .)
    }               reduce using rule 41 (term -> function_call .)
    IF              reduce using rule 41 (term -> function_call .)
    TRY             reduce using rule 41 (term -> function_call .)
    RET             reduce using rule 41 (term -> function_call .)
    GLOBAL          reduce using rule 41 (term -> function_call .)
    UNITARY_OPERATOR reduce using rule 41 (term -> function_call .)
    FLOAT           reduce using rule 41 (term -> function_call .)
    INTEGER         reduce using rule 41 (term -> function_call .)
    BOOLEAN         reduce using rule 41 (term -> function_call .)
    STRING          reduce using rule 41 (term -> function_call .)
    [               reduce using rule 41 (term -> function_call .)
    {               reduce using rule 41 (term -> function_call .)
    ]               reduce using rule 41 (term -> function_call .)
    :               reduce using rule 41 (term -> function_call .)


state 30

    (43) term -> list .

    )               reduce using rule 43 (term -> list .)
    ,               reduce using rule 43 (term -> list .)
    SIGN            reduce using rule 43 (term -> list .)
    BINARY_OPERATOR reduce using rule 43 (term -> list .)
    FN              reduce using rule 43 (term -> list .)
    COMMAND         reduce using rule 43 (term -> list .)
    TOKEN           reduce using rule 43 (term -> list .)
    ID              reduce using rule 43 (term -> list .)
    $end            reduce using rule 43 (term -> list .)
    }               reduce using rule 43 (term -> list .)
    IF              reduce using rule 43 (term -> list .)
    TRY             reduce using rule 43 (term -> list .)
    RET             reduce using rule 43 (term -> list .)
    GLOBAL          reduce using rule 43 (term -> list .)
    UNITARY_OPERATOR reduce using rule 43 (term -> list .)
    FLOAT           reduce using rule 43 (term -> list .)
    INTEGER         reduce using rule 43 (term -> list .)
    BOOLEAN         reduce using rule 43 (term -> list .)
    STRING          reduce using rule 43 (term -> list .)
    [               reduce using rule 43 (term -> list .)
    {               reduce using rule 43 (term -> list .)
    ]               reduce using rule 43 (term -> list .)
    :               reduce using rule 43 (term -> list .)


state 31

    (44) term -> dict .

    )               reduce using rule 44 (term -> dict .)
    ,               reduce using rule 44 (term -> dict .)
    SIGN            reduce using rule 44 (term -> dict .)
    BINARY_OPERATOR reduce using rule 44 (term -> dict .)
    FN              reduce using rule 44 (term -> dict .)
    COMMAND         reduce using rule 44 (term -> dict .)
    TOKEN           reduce using rule 44 (term -> dict .)
    ID              reduce using rule 44 (term -> dict .)
    $end            reduce using rule 44 (term -> dict .)
    }               reduce using rule 44 (term -> dict .)
    IF              reduce using rule 44 (term -> dict .)
    TRY             reduce using rule 44 (term -> dict .)
    RET             reduce using rule 44 (term -> dict .)
    GLOBAL          reduce using rule 44 (term -> dict .)
    UNITARY_OPERATOR reduce using rule 44 (term -> dict .)
    FLOAT           reduce using rule 44 (term -> dict .)
    INTEGER         reduce using rule 44 (term -> dict .)
    BOOLEAN         reduce using rule 44 (term -> dict .)
    STRING          reduce using rule 44 (term -> dict .)
    [               reduce using rule 44 (term -> dict .)
    {               reduce using rule 44 (term -> dict .)
    ]               reduce using rule 44 (term -> dict .)
    :               reduce using rule 44 (term -> dict .)


state 32

    (45) term -> empty .

    )               reduce using rule 45 (term -> empty .)
    ,               reduce using rule 45 (term -> empty .)
    SIGN            reduce using rule 45 (term -> empty .)
    BINARY_OPERATOR reduce using rule 45 (term -> empty .)
    FN              reduce using rule 45 (term -> empty .)
    COMMAND         reduce using rule 45 (term -> empty .)
    TOKEN           reduce using rule 45 (term -> empty .)
    ID              reduce using rule 45 (term -> empty .)
    $end            reduce using rule 45 (term -> empty .)
    }               reduce using rule 45 (term -> empty .)
    IF              reduce using rule 45 (term -> empty .)
    TRY             reduce using rule 45 (term -> empty .)
    RET             reduce using rule 45 (term -> empty .)
    GLOBAL          reduce using rule 45 (term -> empty .)
    UNITARY_OPERATOR reduce using rule 45 (term -> empty .)
    FLOAT           reduce using rule 45 (term -> empty .)
    INTEGER         reduce using rule 45 (term -> empty .)
    BOOLEAN         reduce using rule 45 (term -> empty .)
    STRING          reduce using rule 45 (term -> empty .)
    [               reduce using rule 45 (term -> empty .)
    {               reduce using rule 45 (term -> empty .)
    ]               reduce using rule 45 (term -> empty .)
    :               reduce using rule 45 (term -> empty .)


state 33

    (46) unop -> SIGN .

    SIGN            reduce using rule 46 (unop -> SIGN .)
    UNITARY_OPERATOR reduce using rule 46 (unop -> SIGN .)
    FLOAT           reduce using rule 46 (unop -> SIGN .)
    INTEGER         reduce using rule 46 (unop -> SIGN .)
    BOOLEAN         reduce using rule 46 (unop -> SIGN .)
    STRING          reduce using rule 46 (unop -> SIGN .)
    ID              reduce using rule 46 (unop -> SIGN .)
    [               reduce using rule 46 (unop -> SIGN .)
    {               reduce using rule 46 (unop -> SIGN .)
    )               reduce using rule 46 (unop -> SIGN .)
    ,               reduce using rule 46 (unop -> SIGN .)
    BINARY_OPERATOR reduce using rule 46 (unop -> SIGN .)
    FN              reduce using rule 46 (unop -> SIGN .)
    COMMAND         reduce using rule 46 (unop -> SIGN .)
    TOKEN           reduce using rule 46 (unop -> SIGN .)
    $end            reduce using rule 46 (unop -> SIGN .)
    }               reduce using rule 46 (unop -> SIGN .)
    IF              reduce using rule 46 (unop -> SIGN .)
    TRY             reduce using rule 46 (unop -> SIGN .)
    RET             reduce using rule 46 (unop -> SIGN .)
    GLOBAL          reduce using rule 46 (unop -> SIGN .)
    ]               reduce using rule 46 (unop -> SIGN .)
    :               reduce using rule 46 (unop -> SIGN .)


state 34

    (47) unop -> UNITARY_OPERATOR .

    SIGN            reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    UNITARY_OPERATOR reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    FLOAT           reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    INTEGER         reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    BOOLEAN         reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    STRING          reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    ID              reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    [               reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    {               reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    )               reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    ,               reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    BINARY_OPERATOR reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    FN              reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    COMMAND         reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    TOKEN           reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    $end            reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    }               reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    IF              reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    TRY             reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    RET             reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    GLOBAL          reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    ]               reduce using rule 47 (unop -> UNITARY_OPERATOR .)
    :               reduce using rule 47 (unop -> UNITARY_OPERATOR .)


state 35

    (53) number -> FLOAT .

    )               reduce using rule 53 (number -> FLOAT .)
    ,               reduce using rule 53 (number -> FLOAT .)
    SIGN            reduce using rule 53 (number -> FLOAT .)
    BINARY_OPERATOR reduce using rule 53 (number -> FLOAT .)
    FN              reduce using rule 53 (number -> FLOAT .)
    COMMAND         reduce using rule 53 (number -> FLOAT .)
    TOKEN           reduce using rule 53 (number -> FLOAT .)
    ID              reduce using rule 53 (number -> FLOAT .)
    $end            reduce using rule 53 (number -> FLOAT .)
    }               reduce using rule 53 (number -> FLOAT .)
    IF              reduce using rule 53 (number -> FLOAT .)
    TRY             reduce using rule 53 (number -> FLOAT .)
    RET             reduce using rule 53 (number -> FLOAT .)
    GLOBAL          reduce using rule 53 (number -> FLOAT .)
    UNITARY_OPERATOR reduce using rule 53 (number -> FLOAT .)
    FLOAT           reduce using rule 53 (number -> FLOAT .)
    INTEGER         reduce using rule 53 (number -> FLOAT .)
    BOOLEAN         reduce using rule 53 (number -> FLOAT .)
    STRING          reduce using rule 53 (number -> FLOAT .)
    [               reduce using rule 53 (number -> FLOAT .)
    {               reduce using rule 53 (number -> FLOAT .)
    ]               reduce using rule 53 (number -> FLOAT .)
    :               reduce using rule 53 (number -> FLOAT .)


state 36

    (54) number -> INTEGER .

    )               reduce using rule 54 (number -> INTEGER .)
    ,               reduce using rule 54 (number -> INTEGER .)
    SIGN            reduce using rule 54 (number -> INTEGER .)
    BINARY_OPERATOR reduce using rule 54 (number -> INTEGER .)
    FN              reduce using rule 54 (number -> INTEGER .)
    COMMAND         reduce using rule 54 (number -> INTEGER .)
    TOKEN           reduce using rule 54 (number -> INTEGER .)
    ID              reduce using rule 54 (number -> INTEGER .)
    $end            reduce using rule 54 (number -> INTEGER .)
    }               reduce using rule 54 (number -> INTEGER .)
    IF              reduce using rule 54 (number -> INTEGER .)
    TRY             reduce using rule 54 (number -> INTEGER .)
    RET             reduce using rule 54 (number -> INTEGER .)
    GLOBAL          reduce using rule 54 (number -> INTEGER .)
    UNITARY_OPERATOR reduce using rule 54 (number -> INTEGER .)
    FLOAT           reduce using rule 54 (number -> INTEGER .)
    INTEGER         reduce using rule 54 (number -> INTEGER .)
    BOOLEAN         reduce using rule 54 (number -> INTEGER .)
    STRING          reduce using rule 54 (number -> INTEGER .)
    [               reduce using rule 54 (number -> INTEGER .)
    {               reduce using rule 54 (number -> INTEGER .)
    ]               reduce using rule 54 (number -> INTEGER .)
    :               reduce using rule 54 (number -> INTEGER .)


state 37

    (55) boolean -> BOOLEAN .

    )               reduce using rule 55 (boolean -> BOOLEAN .)
    ,               reduce using rule 55 (boolean -> BOOLEAN .)
    SIGN            reduce using rule 55 (boolean -> BOOLEAN .)
    BINARY_OPERATOR reduce using rule 55 (boolean -> BOOLEAN .)
    FN              reduce using rule 55 (boolean -> BOOLEAN .)
    COMMAND         reduce using rule 55 (boolean -> BOOLEAN .)
    TOKEN           reduce using rule 55 (boolean -> BOOLEAN .)
    ID              reduce using rule 55 (boolean -> BOOLEAN .)
    $end            reduce using rule 55 (boolean -> BOOLEAN .)
    }               reduce using rule 55 (boolean -> BOOLEAN .)
    IF              reduce using rule 55 (boolean -> BOOLEAN .)
    TRY             reduce using rule 55 (boolean -> BOOLEAN .)
    RET             reduce using rule 55 (boolean -> BOOLEAN .)
    GLOBAL          reduce using rule 55 (boolean -> BOOLEAN .)
    UNITARY_OPERATOR reduce using rule 55 (boolean -> BOOLEAN .)
    FLOAT           reduce using rule 55 (boolean -> BOOLEAN .)
    INTEGER         reduce using rule 55 (boolean -> BOOLEAN .)
    BOOLEAN         reduce using rule 55 (boolean -> BOOLEAN .)
    STRING          reduce using rule 55 (boolean -> BOOLEAN .)
    [               reduce using rule 55 (boolean -> BOOLEAN .)
    {               reduce using rule 55 (boolean -> BOOLEAN .)
    ]               reduce using rule 55 (boolean -> BOOLEAN .)
    :               reduce using rule 55 (boolean -> BOOLEAN .)


state 38

    (56) string -> STRING .

    )               reduce using rule 56 (string -> STRING .)
    ,               reduce using rule 56 (string -> STRING .)
    SIGN            reduce using rule 56 (string -> STRING .)
    BINARY_OPERATOR reduce using rule 56 (string -> STRING .)
    FN              reduce using rule 56 (string -> STRING .)
    COMMAND         reduce using rule 56 (string -> STRING .)
    TOKEN           reduce using rule 56 (string -> STRING .)
    ID              reduce using rule 56 (string -> STRING .)
    $end            reduce using rule 56 (string -> STRING .)
    }               reduce using rule 56 (string -> STRING .)
    IF              reduce using rule 56 (string -> STRING .)
    TRY             reduce using rule 56 (string -> STRING .)
    RET             reduce using rule 56 (string -> STRING .)
    GLOBAL          reduce using rule 56 (string -> STRING .)
    UNITARY_OPERATOR reduce using rule 56 (string -> STRING .)
    FLOAT           reduce using rule 56 (string -> STRING .)
    INTEGER         reduce using rule 56 (string -> STRING .)
    BOOLEAN         reduce using rule 56 (string -> STRING .)
    STRING          reduce using rule 56 (string -> STRING .)
    [               reduce using rule 56 (string -> STRING .)
    {               reduce using rule 56 (string -> STRING .)
    ]               reduce using rule 56 (string -> STRING .)
    :               reduce using rule 56 (string -> STRING .)


state 39

    (52) list -> [ . term_list ]
    (35) term_list -> . term_list , term
    (36) term_list -> . term
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    ]               reduce using rule 58 (empty -> .)
    ,               reduce using rule 58 (empty -> .)

    term_list                      shift and go to state 53
    term                           shift and go to state 24
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 40

    (50) dict -> { . term_map }
    (51) dict -> { . empty }
    (33) term_map -> . term : term , term_map
    (34) term_map -> . term : term
    (58) empty -> .
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }

    }               reduce using rule 58 (empty -> .)
    :               reduce using rule 58 (empty -> .)
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40

    term_map                       shift and go to state 54
    empty                          shift and go to state 55
    term                           shift and go to state 56
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31

state 41

    (30) variable -> id = exp .

    FN              reduce using rule 30 (variable -> id = exp .)
    COMMAND         reduce using rule 30 (variable -> id = exp .)
    TOKEN           reduce using rule 30 (variable -> id = exp .)
    ID              reduce using rule 30 (variable -> id = exp .)
    $end            reduce using rule 30 (variable -> id = exp .)
    }               reduce using rule 30 (variable -> id = exp .)
    IF              reduce using rule 30 (variable -> id = exp .)
    TRY             reduce using rule 30 (variable -> id = exp .)
    RET             reduce using rule 30 (variable -> id = exp .)
    GLOBAL          reduce using rule 30 (variable -> id = exp .)
    SIGN            reduce using rule 30 (variable -> id = exp .)
    UNITARY_OPERATOR reduce using rule 30 (variable -> id = exp .)
    FLOAT           reduce using rule 30 (variable -> id = exp .)
    INTEGER         reduce using rule 30 (variable -> id = exp .)
    BOOLEAN         reduce using rule 30 (variable -> id = exp .)
    STRING          reduce using rule 30 (variable -> id = exp .)
    [               reduce using rule 30 (variable -> id = exp .)
    {               reduce using rule 30 (variable -> id = exp .)
    BINARY_OPERATOR reduce using rule 30 (variable -> id = exp .)


state 42

    (25) exp -> term . binop exp
    (26) exp -> term .
    (48) binop -> . SIGN
    (49) binop -> . BINARY_OPERATOR

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for BINARY_OPERATOR resolved as shift
    FN              reduce using rule 26 (exp -> term .)
    COMMAND         reduce using rule 26 (exp -> term .)
    TOKEN           reduce using rule 26 (exp -> term .)
    ID              reduce using rule 26 (exp -> term .)
    $end            reduce using rule 26 (exp -> term .)
    }               reduce using rule 26 (exp -> term .)
    IF              reduce using rule 26 (exp -> term .)
    TRY             reduce using rule 26 (exp -> term .)
    RET             reduce using rule 26 (exp -> term .)
    GLOBAL          reduce using rule 26 (exp -> term .)
    UNITARY_OPERATOR reduce using rule 26 (exp -> term .)
    FLOAT           reduce using rule 26 (exp -> term .)
    INTEGER         reduce using rule 26 (exp -> term .)
    BOOLEAN         reduce using rule 26 (exp -> term .)
    STRING          reduce using rule 26 (exp -> term .)
    [               reduce using rule 26 (exp -> term .)
    {               reduce using rule 26 (exp -> term .)
    SIGN            shift and go to state 58
    BINARY_OPERATOR shift and go to state 59

  ! SIGN            [ reduce using rule 26 (exp -> term .) ]
  ! BINARY_OPERATOR [ reduce using rule 26 (exp -> term .) ]

    binop                          shift and go to state 57

state 43

    (27) exp -> IF . exp { body } ELSE { body }
    (28) exp -> IF . exp { body }
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    exp                            shift and go to state 60
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 44

    (29) exp -> TRY . { body } CATCH { body }

    {               shift and go to state 61


state 45

    (11) function -> COMMAND id ( . parameter ) { body }
    (14) parameter -> . id , parameter
    (15) parameter -> . id
    (16) parameter -> . empty
    (57) id -> . ID
    (58) empty -> .

    ID              shift and go to state 11
    )               reduce using rule 58 (empty -> .)

    id                             shift and go to state 47
    parameter                      shift and go to state 62
    empty                          shift and go to state 49

state 46

    (12) token -> TOKEN ( string . )

    )               shift and go to state 63


state 47

    (14) parameter -> id . , parameter
    (15) parameter -> id .

    ,               shift and go to state 64
    )               reduce using rule 15 (parameter -> id .)


state 48

    (10) function -> FN id ( parameter . ) { body }

    )               shift and go to state 65


state 49

    (16) parameter -> empty .

    )               reduce using rule 16 (parameter -> empty .)


state 50

    (13) function_call -> id ( term_list ) .

    FN              reduce using rule 13 (function_call -> id ( term_list ) .)
    COMMAND         reduce using rule 13 (function_call -> id ( term_list ) .)
    TOKEN           reduce using rule 13 (function_call -> id ( term_list ) .)
    ID              reduce using rule 13 (function_call -> id ( term_list ) .)
    $end            reduce using rule 13 (function_call -> id ( term_list ) .)
    )               reduce using rule 13 (function_call -> id ( term_list ) .)
    ,               reduce using rule 13 (function_call -> id ( term_list ) .)
    SIGN            reduce using rule 13 (function_call -> id ( term_list ) .)
    BINARY_OPERATOR reduce using rule 13 (function_call -> id ( term_list ) .)
    }               reduce using rule 13 (function_call -> id ( term_list ) .)
    IF              reduce using rule 13 (function_call -> id ( term_list ) .)
    TRY             reduce using rule 13 (function_call -> id ( term_list ) .)
    RET             reduce using rule 13 (function_call -> id ( term_list ) .)
    GLOBAL          reduce using rule 13 (function_call -> id ( term_list ) .)
    UNITARY_OPERATOR reduce using rule 13 (function_call -> id ( term_list ) .)
    FLOAT           reduce using rule 13 (function_call -> id ( term_list ) .)
    INTEGER         reduce using rule 13 (function_call -> id ( term_list ) .)
    BOOLEAN         reduce using rule 13 (function_call -> id ( term_list ) .)
    STRING          reduce using rule 13 (function_call -> id ( term_list ) .)
    [               reduce using rule 13 (function_call -> id ( term_list ) .)
    {               reduce using rule 13 (function_call -> id ( term_list ) .)
    ]               reduce using rule 13 (function_call -> id ( term_list ) .)
    :               reduce using rule 13 (function_call -> id ( term_list ) .)


state 51

    (35) term_list -> term_list , . term
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    )               reduce using rule 58 (empty -> .)
    ,               reduce using rule 58 (empty -> .)
    ]               reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)
    IF              reduce using rule 58 (empty -> .)
    TRY             reduce using rule 58 (empty -> .)
    RET             reduce using rule 58 (empty -> .)
    GLOBAL          reduce using rule 58 (empty -> .)
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    term                           shift and go to state 66
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 52

    (37) term -> unop term .

    )               reduce using rule 37 (term -> unop term .)
    ,               reduce using rule 37 (term -> unop term .)
    SIGN            reduce using rule 37 (term -> unop term .)
    BINARY_OPERATOR reduce using rule 37 (term -> unop term .)
    FN              reduce using rule 37 (term -> unop term .)
    COMMAND         reduce using rule 37 (term -> unop term .)
    TOKEN           reduce using rule 37 (term -> unop term .)
    ID              reduce using rule 37 (term -> unop term .)
    $end            reduce using rule 37 (term -> unop term .)
    }               reduce using rule 37 (term -> unop term .)
    IF              reduce using rule 37 (term -> unop term .)
    TRY             reduce using rule 37 (term -> unop term .)
    RET             reduce using rule 37 (term -> unop term .)
    GLOBAL          reduce using rule 37 (term -> unop term .)
    UNITARY_OPERATOR reduce using rule 37 (term -> unop term .)
    FLOAT           reduce using rule 37 (term -> unop term .)
    INTEGER         reduce using rule 37 (term -> unop term .)
    BOOLEAN         reduce using rule 37 (term -> unop term .)
    STRING          reduce using rule 37 (term -> unop term .)
    [               reduce using rule 37 (term -> unop term .)
    {               reduce using rule 37 (term -> unop term .)
    ]               reduce using rule 37 (term -> unop term .)
    :               reduce using rule 37 (term -> unop term .)


state 53

    (52) list -> [ term_list . ]
    (35) term_list -> term_list . , term

    ]               shift and go to state 67
    ,               shift and go to state 51


state 54

    (50) dict -> { term_map . }

    }               shift and go to state 68


state 55

    (51) dict -> { empty . }
    (45) term -> empty .

    }               shift and go to state 69
    :               reduce using rule 45 (term -> empty .)


state 56

    (33) term_map -> term . : term , term_map
    (34) term_map -> term . : term

    :               shift and go to state 70


state 57

    (25) exp -> term binop . exp
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    FN              reduce using rule 58 (empty -> .)
    COMMAND         reduce using rule 58 (empty -> .)
    TOKEN           reduce using rule 58 (empty -> .)
    $end            reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)
    RET             reduce using rule 58 (empty -> .)
    GLOBAL          reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    term                           shift and go to state 42
    exp                            shift and go to state 71
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 58

    (48) binop -> SIGN .

    IF              reduce using rule 48 (binop -> SIGN .)
    TRY             reduce using rule 48 (binop -> SIGN .)
    SIGN            reduce using rule 48 (binop -> SIGN .)
    UNITARY_OPERATOR reduce using rule 48 (binop -> SIGN .)
    FLOAT           reduce using rule 48 (binop -> SIGN .)
    INTEGER         reduce using rule 48 (binop -> SIGN .)
    BOOLEAN         reduce using rule 48 (binop -> SIGN .)
    STRING          reduce using rule 48 (binop -> SIGN .)
    ID              reduce using rule 48 (binop -> SIGN .)
    [               reduce using rule 48 (binop -> SIGN .)
    {               reduce using rule 48 (binop -> SIGN .)
    BINARY_OPERATOR reduce using rule 48 (binop -> SIGN .)
    FN              reduce using rule 48 (binop -> SIGN .)
    COMMAND         reduce using rule 48 (binop -> SIGN .)
    TOKEN           reduce using rule 48 (binop -> SIGN .)
    $end            reduce using rule 48 (binop -> SIGN .)
    }               reduce using rule 48 (binop -> SIGN .)
    RET             reduce using rule 48 (binop -> SIGN .)
    GLOBAL          reduce using rule 48 (binop -> SIGN .)


state 59

    (49) binop -> BINARY_OPERATOR .

    IF              reduce using rule 49 (binop -> BINARY_OPERATOR .)
    TRY             reduce using rule 49 (binop -> BINARY_OPERATOR .)
    SIGN            reduce using rule 49 (binop -> BINARY_OPERATOR .)
    UNITARY_OPERATOR reduce using rule 49 (binop -> BINARY_OPERATOR .)
    FLOAT           reduce using rule 49 (binop -> BINARY_OPERATOR .)
    INTEGER         reduce using rule 49 (binop -> BINARY_OPERATOR .)
    BOOLEAN         reduce using rule 49 (binop -> BINARY_OPERATOR .)
    STRING          reduce using rule 49 (binop -> BINARY_OPERATOR .)
    ID              reduce using rule 49 (binop -> BINARY_OPERATOR .)
    [               reduce using rule 49 (binop -> BINARY_OPERATOR .)
    {               reduce using rule 49 (binop -> BINARY_OPERATOR .)
    BINARY_OPERATOR reduce using rule 49 (binop -> BINARY_OPERATOR .)
    FN              reduce using rule 49 (binop -> BINARY_OPERATOR .)
    COMMAND         reduce using rule 49 (binop -> BINARY_OPERATOR .)
    TOKEN           reduce using rule 49 (binop -> BINARY_OPERATOR .)
    $end            reduce using rule 49 (binop -> BINARY_OPERATOR .)
    }               reduce using rule 49 (binop -> BINARY_OPERATOR .)
    RET             reduce using rule 49 (binop -> BINARY_OPERATOR .)
    GLOBAL          reduce using rule 49 (binop -> BINARY_OPERATOR .)


state 60

    (27) exp -> IF exp . { body } ELSE { body }
    (28) exp -> IF exp . { body }

    {               shift and go to state 72


state 61

    (29) exp -> TRY { . body } CATCH { body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . body return
    (20) body -> . body global
    (21) body -> . exp
    (22) body -> . variable
    (23) body -> . return
    (24) body -> . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    body                           shift and go to state 73
    exp                            shift and go to state 74
    variable                       shift and go to state 75
    return                         shift and go to state 76
    global                         shift and go to state 77
    term                           shift and go to state 42
    id                             shift and go to state 78
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 62

    (11) function -> COMMAND id ( parameter . ) { body }

    )               shift and go to state 81


state 63

    (12) token -> TOKEN ( string ) .

    FN              reduce using rule 12 (token -> TOKEN ( string ) .)
    COMMAND         reduce using rule 12 (token -> TOKEN ( string ) .)
    TOKEN           reduce using rule 12 (token -> TOKEN ( string ) .)
    ID              reduce using rule 12 (token -> TOKEN ( string ) .)
    $end            reduce using rule 12 (token -> TOKEN ( string ) .)


state 64

    (14) parameter -> id , . parameter
    (14) parameter -> . id , parameter
    (15) parameter -> . id
    (16) parameter -> . empty
    (57) id -> . ID
    (58) empty -> .

    ID              shift and go to state 11
    )               reduce using rule 58 (empty -> .)

    id                             shift and go to state 47
    parameter                      shift and go to state 82
    empty                          shift and go to state 49

state 65

    (10) function -> FN id ( parameter ) . { body }

    {               shift and go to state 83


state 66

    (35) term_list -> term_list , term .

    )               reduce using rule 35 (term_list -> term_list , term .)
    ,               reduce using rule 35 (term_list -> term_list , term .)
    ]               reduce using rule 35 (term_list -> term_list , term .)
    }               reduce using rule 35 (term_list -> term_list , term .)
    IF              reduce using rule 35 (term_list -> term_list , term .)
    TRY             reduce using rule 35 (term_list -> term_list , term .)
    RET             reduce using rule 35 (term_list -> term_list , term .)
    GLOBAL          reduce using rule 35 (term_list -> term_list , term .)
    ID              reduce using rule 35 (term_list -> term_list , term .)
    SIGN            reduce using rule 35 (term_list -> term_list , term .)
    UNITARY_OPERATOR reduce using rule 35 (term_list -> term_list , term .)
    FLOAT           reduce using rule 35 (term_list -> term_list , term .)
    INTEGER         reduce using rule 35 (term_list -> term_list , term .)
    BOOLEAN         reduce using rule 35 (term_list -> term_list , term .)
    STRING          reduce using rule 35 (term_list -> term_list , term .)
    [               reduce using rule 35 (term_list -> term_list , term .)
    {               reduce using rule 35 (term_list -> term_list , term .)
    BINARY_OPERATOR reduce using rule 35 (term_list -> term_list , term .)


state 67

    (52) list -> [ term_list ] .

    )               reduce using rule 52 (list -> [ term_list ] .)
    ,               reduce using rule 52 (list -> [ term_list ] .)
    SIGN            reduce using rule 52 (list -> [ term_list ] .)
    BINARY_OPERATOR reduce using rule 52 (list -> [ term_list ] .)
    FN              reduce using rule 52 (list -> [ term_list ] .)
    COMMAND         reduce using rule 52 (list -> [ term_list ] .)
    TOKEN           reduce using rule 52 (list -> [ term_list ] .)
    ID              reduce using rule 52 (list -> [ term_list ] .)
    $end            reduce using rule 52 (list -> [ term_list ] .)
    }               reduce using rule 52 (list -> [ term_list ] .)
    IF              reduce using rule 52 (list -> [ term_list ] .)
    TRY             reduce using rule 52 (list -> [ term_list ] .)
    RET             reduce using rule 52 (list -> [ term_list ] .)
    GLOBAL          reduce using rule 52 (list -> [ term_list ] .)
    UNITARY_OPERATOR reduce using rule 52 (list -> [ term_list ] .)
    FLOAT           reduce using rule 52 (list -> [ term_list ] .)
    INTEGER         reduce using rule 52 (list -> [ term_list ] .)
    BOOLEAN         reduce using rule 52 (list -> [ term_list ] .)
    STRING          reduce using rule 52 (list -> [ term_list ] .)
    [               reduce using rule 52 (list -> [ term_list ] .)
    {               reduce using rule 52 (list -> [ term_list ] .)
    ]               reduce using rule 52 (list -> [ term_list ] .)
    :               reduce using rule 52 (list -> [ term_list ] .)


state 68

    (50) dict -> { term_map } .

    )               reduce using rule 50 (dict -> { term_map } .)
    ,               reduce using rule 50 (dict -> { term_map } .)
    SIGN            reduce using rule 50 (dict -> { term_map } .)
    BINARY_OPERATOR reduce using rule 50 (dict -> { term_map } .)
    FN              reduce using rule 50 (dict -> { term_map } .)
    COMMAND         reduce using rule 50 (dict -> { term_map } .)
    TOKEN           reduce using rule 50 (dict -> { term_map } .)
    ID              reduce using rule 50 (dict -> { term_map } .)
    $end            reduce using rule 50 (dict -> { term_map } .)
    }               reduce using rule 50 (dict -> { term_map } .)
    IF              reduce using rule 50 (dict -> { term_map } .)
    TRY             reduce using rule 50 (dict -> { term_map } .)
    RET             reduce using rule 50 (dict -> { term_map } .)
    GLOBAL          reduce using rule 50 (dict -> { term_map } .)
    UNITARY_OPERATOR reduce using rule 50 (dict -> { term_map } .)
    FLOAT           reduce using rule 50 (dict -> { term_map } .)
    INTEGER         reduce using rule 50 (dict -> { term_map } .)
    BOOLEAN         reduce using rule 50 (dict -> { term_map } .)
    STRING          reduce using rule 50 (dict -> { term_map } .)
    [               reduce using rule 50 (dict -> { term_map } .)
    {               reduce using rule 50 (dict -> { term_map } .)
    ]               reduce using rule 50 (dict -> { term_map } .)
    :               reduce using rule 50 (dict -> { term_map } .)


state 69

    (51) dict -> { empty } .

    )               reduce using rule 51 (dict -> { empty } .)
    ,               reduce using rule 51 (dict -> { empty } .)
    SIGN            reduce using rule 51 (dict -> { empty } .)
    BINARY_OPERATOR reduce using rule 51 (dict -> { empty } .)
    FN              reduce using rule 51 (dict -> { empty } .)
    COMMAND         reduce using rule 51 (dict -> { empty } .)
    TOKEN           reduce using rule 51 (dict -> { empty } .)
    ID              reduce using rule 51 (dict -> { empty } .)
    $end            reduce using rule 51 (dict -> { empty } .)
    }               reduce using rule 51 (dict -> { empty } .)
    IF              reduce using rule 51 (dict -> { empty } .)
    TRY             reduce using rule 51 (dict -> { empty } .)
    RET             reduce using rule 51 (dict -> { empty } .)
    GLOBAL          reduce using rule 51 (dict -> { empty } .)
    UNITARY_OPERATOR reduce using rule 51 (dict -> { empty } .)
    FLOAT           reduce using rule 51 (dict -> { empty } .)
    INTEGER         reduce using rule 51 (dict -> { empty } .)
    BOOLEAN         reduce using rule 51 (dict -> { empty } .)
    STRING          reduce using rule 51 (dict -> { empty } .)
    [               reduce using rule 51 (dict -> { empty } .)
    {               reduce using rule 51 (dict -> { empty } .)
    ]               reduce using rule 51 (dict -> { empty } .)
    :               reduce using rule 51 (dict -> { empty } .)


state 70

    (33) term_map -> term : . term , term_map
    (34) term_map -> term : . term
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    ,               reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)

    term                           shift and go to state 84
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 71

    (25) exp -> term binop exp .

    FN              reduce using rule 25 (exp -> term binop exp .)
    COMMAND         reduce using rule 25 (exp -> term binop exp .)
    TOKEN           reduce using rule 25 (exp -> term binop exp .)
    ID              reduce using rule 25 (exp -> term binop exp .)
    $end            reduce using rule 25 (exp -> term binop exp .)
    }               reduce using rule 25 (exp -> term binop exp .)
    IF              reduce using rule 25 (exp -> term binop exp .)
    TRY             reduce using rule 25 (exp -> term binop exp .)
    RET             reduce using rule 25 (exp -> term binop exp .)
    GLOBAL          reduce using rule 25 (exp -> term binop exp .)
    SIGN            reduce using rule 25 (exp -> term binop exp .)
    UNITARY_OPERATOR reduce using rule 25 (exp -> term binop exp .)
    FLOAT           reduce using rule 25 (exp -> term binop exp .)
    INTEGER         reduce using rule 25 (exp -> term binop exp .)
    BOOLEAN         reduce using rule 25 (exp -> term binop exp .)
    STRING          reduce using rule 25 (exp -> term binop exp .)
    [               reduce using rule 25 (exp -> term binop exp .)
    {               reduce using rule 25 (exp -> term binop exp .)
    BINARY_OPERATOR reduce using rule 25 (exp -> term binop exp .)


state 72

    (27) exp -> IF exp { . body } ELSE { body }
    (28) exp -> IF exp { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . body return
    (20) body -> . body global
    (21) body -> . exp
    (22) body -> . variable
    (23) body -> . return
    (24) body -> . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    exp                            shift and go to state 74
    body                           shift and go to state 85
    variable                       shift and go to state 75
    return                         shift and go to state 76
    global                         shift and go to state 77
    term                           shift and go to state 42
    id                             shift and go to state 78
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 73

    (29) exp -> TRY { body . } CATCH { body }
    (17) body -> body . exp
    (18) body -> body . variable
    (19) body -> body . return
    (20) body -> body . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 86
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! }               [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    exp                            shift and go to state 87
    variable                       shift and go to state 88
    return                         shift and go to state 89
    global                         shift and go to state 90
    term                           shift and go to state 42
    id                             shift and go to state 78
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 74

    (21) body -> exp .

    }               reduce using rule 21 (body -> exp .)
    IF              reduce using rule 21 (body -> exp .)
    TRY             reduce using rule 21 (body -> exp .)
    RET             reduce using rule 21 (body -> exp .)
    GLOBAL          reduce using rule 21 (body -> exp .)
    ID              reduce using rule 21 (body -> exp .)
    SIGN            reduce using rule 21 (body -> exp .)
    UNITARY_OPERATOR reduce using rule 21 (body -> exp .)
    FLOAT           reduce using rule 21 (body -> exp .)
    INTEGER         reduce using rule 21 (body -> exp .)
    BOOLEAN         reduce using rule 21 (body -> exp .)
    STRING          reduce using rule 21 (body -> exp .)
    [               reduce using rule 21 (body -> exp .)
    {               reduce using rule 21 (body -> exp .)
    BINARY_OPERATOR reduce using rule 21 (body -> exp .)


state 75

    (22) body -> variable .

    }               reduce using rule 22 (body -> variable .)
    IF              reduce using rule 22 (body -> variable .)
    TRY             reduce using rule 22 (body -> variable .)
    RET             reduce using rule 22 (body -> variable .)
    GLOBAL          reduce using rule 22 (body -> variable .)
    ID              reduce using rule 22 (body -> variable .)
    SIGN            reduce using rule 22 (body -> variable .)
    UNITARY_OPERATOR reduce using rule 22 (body -> variable .)
    FLOAT           reduce using rule 22 (body -> variable .)
    INTEGER         reduce using rule 22 (body -> variable .)
    BOOLEAN         reduce using rule 22 (body -> variable .)
    STRING          reduce using rule 22 (body -> variable .)
    [               reduce using rule 22 (body -> variable .)
    {               reduce using rule 22 (body -> variable .)
    BINARY_OPERATOR reduce using rule 22 (body -> variable .)


state 76

    (23) body -> return .

    }               reduce using rule 23 (body -> return .)
    IF              reduce using rule 23 (body -> return .)
    TRY             reduce using rule 23 (body -> return .)
    RET             reduce using rule 23 (body -> return .)
    GLOBAL          reduce using rule 23 (body -> return .)
    ID              reduce using rule 23 (body -> return .)
    SIGN            reduce using rule 23 (body -> return .)
    UNITARY_OPERATOR reduce using rule 23 (body -> return .)
    FLOAT           reduce using rule 23 (body -> return .)
    INTEGER         reduce using rule 23 (body -> return .)
    BOOLEAN         reduce using rule 23 (body -> return .)
    STRING          reduce using rule 23 (body -> return .)
    [               reduce using rule 23 (body -> return .)
    {               reduce using rule 23 (body -> return .)
    BINARY_OPERATOR reduce using rule 23 (body -> return .)


state 77

    (24) body -> global .

    }               reduce using rule 24 (body -> global .)
    IF              reduce using rule 24 (body -> global .)
    TRY             reduce using rule 24 (body -> global .)
    RET             reduce using rule 24 (body -> global .)
    GLOBAL          reduce using rule 24 (body -> global .)
    ID              reduce using rule 24 (body -> global .)
    SIGN            reduce using rule 24 (body -> global .)
    UNITARY_OPERATOR reduce using rule 24 (body -> global .)
    FLOAT           reduce using rule 24 (body -> global .)
    INTEGER         reduce using rule 24 (body -> global .)
    BOOLEAN         reduce using rule 24 (body -> global .)
    STRING          reduce using rule 24 (body -> global .)
    [               reduce using rule 24 (body -> global .)
    {               reduce using rule 24 (body -> global .)
    BINARY_OPERATOR reduce using rule 24 (body -> global .)


state 78

    (30) variable -> id . = exp
    (42) term -> id .
    (13) function_call -> id . ( term_list )

    =               shift and go to state 18
    SIGN            reduce using rule 42 (term -> id .)
    BINARY_OPERATOR reduce using rule 42 (term -> id .)
    }               reduce using rule 42 (term -> id .)
    IF              reduce using rule 42 (term -> id .)
    TRY             reduce using rule 42 (term -> id .)
    RET             reduce using rule 42 (term -> id .)
    GLOBAL          reduce using rule 42 (term -> id .)
    ID              reduce using rule 42 (term -> id .)
    UNITARY_OPERATOR reduce using rule 42 (term -> id .)
    FLOAT           reduce using rule 42 (term -> id .)
    INTEGER         reduce using rule 42 (term -> id .)
    BOOLEAN         reduce using rule 42 (term -> id .)
    STRING          reduce using rule 42 (term -> id .)
    [               reduce using rule 42 (term -> id .)
    {               reduce using rule 42 (term -> id .)
    (               shift and go to state 17


state 79

    (31) return -> RET . id
    (57) id -> . ID

    ID              shift and go to state 11

    id                             shift and go to state 91

state 80

    (32) global -> GLOBAL . term_list
    (35) term_list -> . term_list , term
    (36) term_list -> . term
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    ,               reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)
    IF              reduce using rule 58 (empty -> .)
    TRY             reduce using rule 58 (empty -> .)
    RET             reduce using rule 58 (empty -> .)
    GLOBAL          reduce using rule 58 (empty -> .)
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    term_list                      shift and go to state 92
    term                           shift and go to state 24
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 81

    (11) function -> COMMAND id ( parameter ) . { body }

    {               shift and go to state 93


state 82

    (14) parameter -> id , parameter .

    )               reduce using rule 14 (parameter -> id , parameter .)


state 83

    (10) function -> FN id ( parameter ) { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . body return
    (20) body -> . body global
    (21) body -> . exp
    (22) body -> . variable
    (23) body -> . return
    (24) body -> . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    id                             shift and go to state 78
    body                           shift and go to state 94
    exp                            shift and go to state 74
    variable                       shift and go to state 75
    return                         shift and go to state 76
    global                         shift and go to state 77
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 84

    (33) term_map -> term : term . , term_map
    (34) term_map -> term : term .

    ,               shift and go to state 95
    }               reduce using rule 34 (term_map -> term : term .)


state 85

    (27) exp -> IF exp { body . } ELSE { body }
    (28) exp -> IF exp { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (19) body -> body . return
    (20) body -> body . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 96
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! }               [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    exp                            shift and go to state 87
    variable                       shift and go to state 88
    return                         shift and go to state 89
    global                         shift and go to state 90
    term                           shift and go to state 42
    id                             shift and go to state 78
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 86

    (29) exp -> TRY { body } . CATCH { body }

    CATCH           shift and go to state 97


state 87

    (17) body -> body exp .

    }               reduce using rule 17 (body -> body exp .)
    IF              reduce using rule 17 (body -> body exp .)
    TRY             reduce using rule 17 (body -> body exp .)
    RET             reduce using rule 17 (body -> body exp .)
    GLOBAL          reduce using rule 17 (body -> body exp .)
    ID              reduce using rule 17 (body -> body exp .)
    SIGN            reduce using rule 17 (body -> body exp .)
    UNITARY_OPERATOR reduce using rule 17 (body -> body exp .)
    FLOAT           reduce using rule 17 (body -> body exp .)
    INTEGER         reduce using rule 17 (body -> body exp .)
    BOOLEAN         reduce using rule 17 (body -> body exp .)
    STRING          reduce using rule 17 (body -> body exp .)
    [               reduce using rule 17 (body -> body exp .)
    {               reduce using rule 17 (body -> body exp .)
    BINARY_OPERATOR reduce using rule 17 (body -> body exp .)


state 88

    (18) body -> body variable .

    }               reduce using rule 18 (body -> body variable .)
    IF              reduce using rule 18 (body -> body variable .)
    TRY             reduce using rule 18 (body -> body variable .)
    RET             reduce using rule 18 (body -> body variable .)
    GLOBAL          reduce using rule 18 (body -> body variable .)
    ID              reduce using rule 18 (body -> body variable .)
    SIGN            reduce using rule 18 (body -> body variable .)
    UNITARY_OPERATOR reduce using rule 18 (body -> body variable .)
    FLOAT           reduce using rule 18 (body -> body variable .)
    INTEGER         reduce using rule 18 (body -> body variable .)
    BOOLEAN         reduce using rule 18 (body -> body variable .)
    STRING          reduce using rule 18 (body -> body variable .)
    [               reduce using rule 18 (body -> body variable .)
    {               reduce using rule 18 (body -> body variable .)
    BINARY_OPERATOR reduce using rule 18 (body -> body variable .)


state 89

    (19) body -> body return .

    }               reduce using rule 19 (body -> body return .)
    IF              reduce using rule 19 (body -> body return .)
    TRY             reduce using rule 19 (body -> body return .)
    RET             reduce using rule 19 (body -> body return .)
    GLOBAL          reduce using rule 19 (body -> body return .)
    ID              reduce using rule 19 (body -> body return .)
    SIGN            reduce using rule 19 (body -> body return .)
    UNITARY_OPERATOR reduce using rule 19 (body -> body return .)
    FLOAT           reduce using rule 19 (body -> body return .)
    INTEGER         reduce using rule 19 (body -> body return .)
    BOOLEAN         reduce using rule 19 (body -> body return .)
    STRING          reduce using rule 19 (body -> body return .)
    [               reduce using rule 19 (body -> body return .)
    {               reduce using rule 19 (body -> body return .)
    BINARY_OPERATOR reduce using rule 19 (body -> body return .)


state 90

    (20) body -> body global .

    }               reduce using rule 20 (body -> body global .)
    IF              reduce using rule 20 (body -> body global .)
    TRY             reduce using rule 20 (body -> body global .)
    RET             reduce using rule 20 (body -> body global .)
    GLOBAL          reduce using rule 20 (body -> body global .)
    ID              reduce using rule 20 (body -> body global .)
    SIGN            reduce using rule 20 (body -> body global .)
    UNITARY_OPERATOR reduce using rule 20 (body -> body global .)
    FLOAT           reduce using rule 20 (body -> body global .)
    INTEGER         reduce using rule 20 (body -> body global .)
    BOOLEAN         reduce using rule 20 (body -> body global .)
    STRING          reduce using rule 20 (body -> body global .)
    [               reduce using rule 20 (body -> body global .)
    {               reduce using rule 20 (body -> body global .)
    BINARY_OPERATOR reduce using rule 20 (body -> body global .)


state 91

    (31) return -> RET id .

    }               reduce using rule 31 (return -> RET id .)
    IF              reduce using rule 31 (return -> RET id .)
    TRY             reduce using rule 31 (return -> RET id .)
    RET             reduce using rule 31 (return -> RET id .)
    GLOBAL          reduce using rule 31 (return -> RET id .)
    ID              reduce using rule 31 (return -> RET id .)
    SIGN            reduce using rule 31 (return -> RET id .)
    UNITARY_OPERATOR reduce using rule 31 (return -> RET id .)
    FLOAT           reduce using rule 31 (return -> RET id .)
    INTEGER         reduce using rule 31 (return -> RET id .)
    BOOLEAN         reduce using rule 31 (return -> RET id .)
    STRING          reduce using rule 31 (return -> RET id .)
    [               reduce using rule 31 (return -> RET id .)
    {               reduce using rule 31 (return -> RET id .)
    BINARY_OPERATOR reduce using rule 31 (return -> RET id .)


state 92

    (32) global -> GLOBAL term_list .
    (35) term_list -> term_list . , term

    }               reduce using rule 32 (global -> GLOBAL term_list .)
    IF              reduce using rule 32 (global -> GLOBAL term_list .)
    TRY             reduce using rule 32 (global -> GLOBAL term_list .)
    RET             reduce using rule 32 (global -> GLOBAL term_list .)
    GLOBAL          reduce using rule 32 (global -> GLOBAL term_list .)
    ID              reduce using rule 32 (global -> GLOBAL term_list .)
    SIGN            reduce using rule 32 (global -> GLOBAL term_list .)
    UNITARY_OPERATOR reduce using rule 32 (global -> GLOBAL term_list .)
    FLOAT           reduce using rule 32 (global -> GLOBAL term_list .)
    INTEGER         reduce using rule 32 (global -> GLOBAL term_list .)
    BOOLEAN         reduce using rule 32 (global -> GLOBAL term_list .)
    STRING          reduce using rule 32 (global -> GLOBAL term_list .)
    [               reduce using rule 32 (global -> GLOBAL term_list .)
    {               reduce using rule 32 (global -> GLOBAL term_list .)
    BINARY_OPERATOR reduce using rule 32 (global -> GLOBAL term_list .)
    ,               shift and go to state 51


state 93

    (11) function -> COMMAND id ( parameter ) { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . body return
    (20) body -> . body global
    (21) body -> . exp
    (22) body -> . variable
    (23) body -> . return
    (24) body -> . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    id                             shift and go to state 78
    body                           shift and go to state 98
    exp                            shift and go to state 74
    variable                       shift and go to state 75
    return                         shift and go to state 76
    global                         shift and go to state 77
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 94

    (10) function -> FN id ( parameter ) { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (19) body -> body . return
    (20) body -> body . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 99
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! }               [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    id                             shift and go to state 78
    exp                            shift and go to state 87
    variable                       shift and go to state 88
    return                         shift and go to state 89
    global                         shift and go to state 90
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 95

    (33) term_map -> term : term , . term_map
    (33) term_map -> . term : term , term_map
    (34) term_map -> . term : term
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (57) id -> . ID
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    ID              shift and go to state 11
    [               shift and go to state 39
    {               shift and go to state 40
    :               reduce using rule 58 (empty -> .)

    term                           shift and go to state 56
    term_map                       shift and go to state 100
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    id                             shift and go to state 22
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 96

    (27) exp -> IF exp { body } . ELSE { body }
    (28) exp -> IF exp { body } .

    ELSE            shift and go to state 101
    FN              reduce using rule 28 (exp -> IF exp { body } .)
    COMMAND         reduce using rule 28 (exp -> IF exp { body } .)
    TOKEN           reduce using rule 28 (exp -> IF exp { body } .)
    ID              reduce using rule 28 (exp -> IF exp { body } .)
    $end            reduce using rule 28 (exp -> IF exp { body } .)
    }               reduce using rule 28 (exp -> IF exp { body } .)
    IF              reduce using rule 28 (exp -> IF exp { body } .)
    TRY             reduce using rule 28 (exp -> IF exp { body } .)
    RET             reduce using rule 28 (exp -> IF exp { body } .)
    GLOBAL          reduce using rule 28 (exp -> IF exp { body } .)
    SIGN            reduce using rule 28 (exp -> IF exp { body } .)
    UNITARY_OPERATOR reduce using rule 28 (exp -> IF exp { body } .)
    FLOAT           reduce using rule 28 (exp -> IF exp { body } .)
    INTEGER         reduce using rule 28 (exp -> IF exp { body } .)
    BOOLEAN         reduce using rule 28 (exp -> IF exp { body } .)
    STRING          reduce using rule 28 (exp -> IF exp { body } .)
    [               reduce using rule 28 (exp -> IF exp { body } .)
    {               reduce using rule 28 (exp -> IF exp { body } .)
    BINARY_OPERATOR reduce using rule 28 (exp -> IF exp { body } .)


state 97

    (29) exp -> TRY { body } CATCH . { body }

    {               shift and go to state 102


state 98

    (11) function -> COMMAND id ( parameter ) { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (19) body -> body . return
    (20) body -> body . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 103
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! }               [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    id                             shift and go to state 78
    exp                            shift and go to state 87
    variable                       shift and go to state 88
    return                         shift and go to state 89
    global                         shift and go to state 90
    term                           shift and go to state 42
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 99

    (10) function -> FN id ( parameter ) { body } .

    FN              reduce using rule 10 (function -> FN id ( parameter ) { body } .)
    COMMAND         reduce using rule 10 (function -> FN id ( parameter ) { body } .)
    TOKEN           reduce using rule 10 (function -> FN id ( parameter ) { body } .)
    ID              reduce using rule 10 (function -> FN id ( parameter ) { body } .)
    $end            reduce using rule 10 (function -> FN id ( parameter ) { body } .)


state 100

    (33) term_map -> term : term , term_map .

    }               reduce using rule 33 (term_map -> term : term , term_map .)


state 101

    (27) exp -> IF exp { body } ELSE . { body }

    {               shift and go to state 104


state 102

    (29) exp -> TRY { body } CATCH { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . body return
    (20) body -> . body global
    (21) body -> . exp
    (22) body -> . variable
    (23) body -> . return
    (24) body -> . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    body                           shift and go to state 105
    exp                            shift and go to state 74
    variable                       shift and go to state 75
    return                         shift and go to state 76
    global                         shift and go to state 77
    term                           shift and go to state 42
    id                             shift and go to state 78
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 103

    (11) function -> COMMAND id ( parameter ) { body } .

    FN              reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)
    COMMAND         reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)
    TOKEN           reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)
    ID              reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)
    $end            reduce using rule 11 (function -> COMMAND id ( parameter ) { body } .)


state 104

    (27) exp -> IF exp { body } ELSE { . body }
    (17) body -> . body exp
    (18) body -> . body variable
    (19) body -> . body return
    (20) body -> . body global
    (21) body -> . exp
    (22) body -> . variable
    (23) body -> . return
    (24) body -> . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)
    }               reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    exp                            shift and go to state 74
    body                           shift and go to state 106
    variable                       shift and go to state 75
    return                         shift and go to state 76
    global                         shift and go to state 77
    term                           shift and go to state 42
    id                             shift and go to state 78
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 105

    (29) exp -> TRY { body } CATCH { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (19) body -> body . return
    (20) body -> body . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 107
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! }               [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    exp                            shift and go to state 87
    variable                       shift and go to state 88
    return                         shift and go to state 89
    global                         shift and go to state 90
    term                           shift and go to state 42
    id                             shift and go to state 78
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 106

    (27) exp -> IF exp { body } ELSE { body . }
    (17) body -> body . exp
    (18) body -> body . variable
    (19) body -> body . return
    (20) body -> body . global
    (25) exp -> . term binop exp
    (26) exp -> . term
    (27) exp -> . IF exp { body } ELSE { body }
    (28) exp -> . IF exp { body }
    (29) exp -> . TRY { body } CATCH { body }
    (30) variable -> . id = exp
    (31) return -> . RET id
    (32) global -> . GLOBAL term_list
    (37) term -> . unop term
    (38) term -> . number
    (39) term -> . boolean
    (40) term -> . string
    (41) term -> . function_call
    (42) term -> . id
    (43) term -> . list
    (44) term -> . dict
    (45) term -> . empty
    (57) id -> . ID
    (46) unop -> . SIGN
    (47) unop -> . UNITARY_OPERATOR
    (53) number -> . FLOAT
    (54) number -> . INTEGER
    (55) boolean -> . BOOLEAN
    (56) string -> . STRING
    (13) function_call -> . id ( term_list )
    (52) list -> . [ term_list ]
    (50) dict -> . { term_map }
    (51) dict -> . { empty }
    (58) empty -> .

  ! shift/reduce conflict for SIGN resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for RET resolved as shift
  ! shift/reduce conflict for GLOBAL resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for UNITARY_OPERATOR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for { resolved as shift
    }               shift and go to state 108
    IF              shift and go to state 43
    TRY             shift and go to state 44
    RET             shift and go to state 79
    GLOBAL          shift and go to state 80
    ID              shift and go to state 11
    SIGN            shift and go to state 33
    UNITARY_OPERATOR shift and go to state 34
    FLOAT           shift and go to state 35
    INTEGER         shift and go to state 36
    BOOLEAN         shift and go to state 37
    STRING          shift and go to state 38
    [               shift and go to state 39
    {               shift and go to state 40
    BINARY_OPERATOR reduce using rule 58 (empty -> .)

  ! SIGN            [ reduce using rule 58 (empty -> .) ]
  ! }               [ reduce using rule 58 (empty -> .) ]
  ! IF              [ reduce using rule 58 (empty -> .) ]
  ! TRY             [ reduce using rule 58 (empty -> .) ]
  ! RET             [ reduce using rule 58 (empty -> .) ]
  ! GLOBAL          [ reduce using rule 58 (empty -> .) ]
  ! ID              [ reduce using rule 58 (empty -> .) ]
  ! UNITARY_OPERATOR [ reduce using rule 58 (empty -> .) ]
  ! FLOAT           [ reduce using rule 58 (empty -> .) ]
  ! INTEGER         [ reduce using rule 58 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 58 (empty -> .) ]
  ! STRING          [ reduce using rule 58 (empty -> .) ]
  ! [               [ reduce using rule 58 (empty -> .) ]
  ! {               [ reduce using rule 58 (empty -> .) ]

    exp                            shift and go to state 87
    variable                       shift and go to state 88
    return                         shift and go to state 89
    global                         shift and go to state 90
    term                           shift and go to state 42
    id                             shift and go to state 78
    unop                           shift and go to state 25
    number                         shift and go to state 26
    boolean                        shift and go to state 27
    string                         shift and go to state 28
    function_call                  shift and go to state 29
    list                           shift and go to state 30
    dict                           shift and go to state 31
    empty                          shift and go to state 32

state 107

    (29) exp -> TRY { body } CATCH { body } .

    FN              reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    COMMAND         reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    TOKEN           reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    ID              reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    $end            reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    }               reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    IF              reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    TRY             reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    RET             reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    GLOBAL          reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    SIGN            reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    UNITARY_OPERATOR reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    FLOAT           reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    INTEGER         reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    BOOLEAN         reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    STRING          reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    [               reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    {               reduce using rule 29 (exp -> TRY { body } CATCH { body } .)
    BINARY_OPERATOR reduce using rule 29 (exp -> TRY { body } CATCH { body } .)


state 108

    (27) exp -> IF exp { body } ELSE { body } .

    FN              reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    COMMAND         reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    TOKEN           reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    ID              reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    $end            reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    }               reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    IF              reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    TRY             reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    RET             reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    GLOBAL          reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    SIGN            reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    UNITARY_OPERATOR reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    FLOAT           reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    INTEGER         reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    BOOLEAN         reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    STRING          reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    [               reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    {               reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)
    BINARY_OPERATOR reduce using rule 27 (exp -> IF exp { body } ELSE { body } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SIGN in state 18 resolved as shift
WARNING: shift/reduce conflict for ID in state 18 resolved as shift
WARNING: shift/reduce conflict for IF in state 18 resolved as shift
WARNING: shift/reduce conflict for TRY in state 18 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 18 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 18 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 18 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 18 resolved as shift
WARNING: shift/reduce conflict for STRING in state 18 resolved as shift
WARNING: shift/reduce conflict for [ in state 18 resolved as shift
WARNING: shift/reduce conflict for { in state 18 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 25 resolved as shift
WARNING: shift/reduce conflict for ID in state 25 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 25 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 25 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 25 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 25 resolved as shift
WARNING: shift/reduce conflict for STRING in state 25 resolved as shift
WARNING: shift/reduce conflict for [ in state 25 resolved as shift
WARNING: shift/reduce conflict for { in state 25 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 42 resolved as shift
WARNING: shift/reduce conflict for BINARY_OPERATOR in state 42 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 43 resolved as shift
WARNING: shift/reduce conflict for { in state 43 resolved as shift
WARNING: shift/reduce conflict for ID in state 51 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 51 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 51 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 51 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 51 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 51 resolved as shift
WARNING: shift/reduce conflict for STRING in state 51 resolved as shift
WARNING: shift/reduce conflict for [ in state 51 resolved as shift
WARNING: shift/reduce conflict for { in state 51 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 57 resolved as shift
WARNING: shift/reduce conflict for ID in state 57 resolved as shift
WARNING: shift/reduce conflict for IF in state 57 resolved as shift
WARNING: shift/reduce conflict for TRY in state 57 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 57 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 57 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 57 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 57 resolved as shift
WARNING: shift/reduce conflict for STRING in state 57 resolved as shift
WARNING: shift/reduce conflict for [ in state 57 resolved as shift
WARNING: shift/reduce conflict for { in state 57 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 61 resolved as shift
WARNING: shift/reduce conflict for IF in state 61 resolved as shift
WARNING: shift/reduce conflict for TRY in state 61 resolved as shift
WARNING: shift/reduce conflict for RET in state 61 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 61 resolved as shift
WARNING: shift/reduce conflict for ID in state 61 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 61 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 61 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 61 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 61 resolved as shift
WARNING: shift/reduce conflict for STRING in state 61 resolved as shift
WARNING: shift/reduce conflict for [ in state 61 resolved as shift
WARNING: shift/reduce conflict for { in state 61 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for TRY in state 72 resolved as shift
WARNING: shift/reduce conflict for RET in state 72 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 72 resolved as shift
WARNING: shift/reduce conflict for ID in state 72 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 72 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 72 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 72 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 72 resolved as shift
WARNING: shift/reduce conflict for STRING in state 72 resolved as shift
WARNING: shift/reduce conflict for [ in state 72 resolved as shift
WARNING: shift/reduce conflict for { in state 72 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 73 resolved as shift
WARNING: shift/reduce conflict for } in state 73 resolved as shift
WARNING: shift/reduce conflict for IF in state 73 resolved as shift
WARNING: shift/reduce conflict for TRY in state 73 resolved as shift
WARNING: shift/reduce conflict for RET in state 73 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 73 resolved as shift
WARNING: shift/reduce conflict for ID in state 73 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 73 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 73 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 73 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 73 resolved as shift
WARNING: shift/reduce conflict for STRING in state 73 resolved as shift
WARNING: shift/reduce conflict for [ in state 73 resolved as shift
WARNING: shift/reduce conflict for { in state 73 resolved as shift
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 80 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 80 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 80 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 80 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 80 resolved as shift
WARNING: shift/reduce conflict for STRING in state 80 resolved as shift
WARNING: shift/reduce conflict for [ in state 80 resolved as shift
WARNING: shift/reduce conflict for { in state 80 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 83 resolved as shift
WARNING: shift/reduce conflict for IF in state 83 resolved as shift
WARNING: shift/reduce conflict for TRY in state 83 resolved as shift
WARNING: shift/reduce conflict for RET in state 83 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 83 resolved as shift
WARNING: shift/reduce conflict for ID in state 83 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 83 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 83 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 83 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 83 resolved as shift
WARNING: shift/reduce conflict for STRING in state 83 resolved as shift
WARNING: shift/reduce conflict for [ in state 83 resolved as shift
WARNING: shift/reduce conflict for { in state 83 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 85 resolved as shift
WARNING: shift/reduce conflict for } in state 85 resolved as shift
WARNING: shift/reduce conflict for IF in state 85 resolved as shift
WARNING: shift/reduce conflict for TRY in state 85 resolved as shift
WARNING: shift/reduce conflict for RET in state 85 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 85 resolved as shift
WARNING: shift/reduce conflict for ID in state 85 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 85 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 85 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 85 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 85 resolved as shift
WARNING: shift/reduce conflict for STRING in state 85 resolved as shift
WARNING: shift/reduce conflict for [ in state 85 resolved as shift
WARNING: shift/reduce conflict for { in state 85 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 93 resolved as shift
WARNING: shift/reduce conflict for IF in state 93 resolved as shift
WARNING: shift/reduce conflict for TRY in state 93 resolved as shift
WARNING: shift/reduce conflict for RET in state 93 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 93 resolved as shift
WARNING: shift/reduce conflict for ID in state 93 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 93 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 93 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 93 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 93 resolved as shift
WARNING: shift/reduce conflict for STRING in state 93 resolved as shift
WARNING: shift/reduce conflict for [ in state 93 resolved as shift
WARNING: shift/reduce conflict for { in state 93 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 94 resolved as shift
WARNING: shift/reduce conflict for } in state 94 resolved as shift
WARNING: shift/reduce conflict for IF in state 94 resolved as shift
WARNING: shift/reduce conflict for TRY in state 94 resolved as shift
WARNING: shift/reduce conflict for RET in state 94 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 94 resolved as shift
WARNING: shift/reduce conflict for ID in state 94 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 94 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 94 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 94 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 94 resolved as shift
WARNING: shift/reduce conflict for STRING in state 94 resolved as shift
WARNING: shift/reduce conflict for [ in state 94 resolved as shift
WARNING: shift/reduce conflict for { in state 94 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 98 resolved as shift
WARNING: shift/reduce conflict for } in state 98 resolved as shift
WARNING: shift/reduce conflict for IF in state 98 resolved as shift
WARNING: shift/reduce conflict for TRY in state 98 resolved as shift
WARNING: shift/reduce conflict for RET in state 98 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 98 resolved as shift
WARNING: shift/reduce conflict for ID in state 98 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 98 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 98 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 98 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 98 resolved as shift
WARNING: shift/reduce conflict for STRING in state 98 resolved as shift
WARNING: shift/reduce conflict for [ in state 98 resolved as shift
WARNING: shift/reduce conflict for { in state 98 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 102 resolved as shift
WARNING: shift/reduce conflict for IF in state 102 resolved as shift
WARNING: shift/reduce conflict for TRY in state 102 resolved as shift
WARNING: shift/reduce conflict for RET in state 102 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 102 resolved as shift
WARNING: shift/reduce conflict for ID in state 102 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 102 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 102 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 102 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 102 resolved as shift
WARNING: shift/reduce conflict for STRING in state 102 resolved as shift
WARNING: shift/reduce conflict for [ in state 102 resolved as shift
WARNING: shift/reduce conflict for { in state 102 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 104 resolved as shift
WARNING: shift/reduce conflict for IF in state 104 resolved as shift
WARNING: shift/reduce conflict for TRY in state 104 resolved as shift
WARNING: shift/reduce conflict for RET in state 104 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 104 resolved as shift
WARNING: shift/reduce conflict for ID in state 104 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 104 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 104 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 104 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 104 resolved as shift
WARNING: shift/reduce conflict for STRING in state 104 resolved as shift
WARNING: shift/reduce conflict for [ in state 104 resolved as shift
WARNING: shift/reduce conflict for { in state 104 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 105 resolved as shift
WARNING: shift/reduce conflict for } in state 105 resolved as shift
WARNING: shift/reduce conflict for IF in state 105 resolved as shift
WARNING: shift/reduce conflict for TRY in state 105 resolved as shift
WARNING: shift/reduce conflict for RET in state 105 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 105 resolved as shift
WARNING: shift/reduce conflict for ID in state 105 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 105 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 105 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 105 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 105 resolved as shift
WARNING: shift/reduce conflict for STRING in state 105 resolved as shift
WARNING: shift/reduce conflict for [ in state 105 resolved as shift
WARNING: shift/reduce conflict for { in state 105 resolved as shift
WARNING: shift/reduce conflict for SIGN in state 106 resolved as shift
WARNING: shift/reduce conflict for } in state 106 resolved as shift
WARNING: shift/reduce conflict for IF in state 106 resolved as shift
WARNING: shift/reduce conflict for TRY in state 106 resolved as shift
WARNING: shift/reduce conflict for RET in state 106 resolved as shift
WARNING: shift/reduce conflict for GLOBAL in state 106 resolved as shift
WARNING: shift/reduce conflict for ID in state 106 resolved as shift
WARNING: shift/reduce conflict for UNITARY_OPERATOR in state 106 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 106 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 106 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 106 resolved as shift
WARNING: shift/reduce conflict for STRING in state 106 resolved as shift
WARNING: shift/reduce conflict for [ in state 106 resolved as shift
WARNING: shift/reduce conflict for { in state 106 resolved as shift
